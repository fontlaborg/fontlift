Project Structure:
ğŸ“ fontlift
â”œâ”€â”€ ğŸ“ .github
â”‚   â””â”€â”€ ğŸ“ workflows
â”‚       â”œâ”€â”€ ğŸ“„ ci.yml
â”‚       â””â”€â”€ ğŸ“„ release.yml
â”œâ”€â”€ ğŸ“ crates
â”‚   â”œâ”€â”€ ğŸ“ fontlift-cli
â”‚   â”‚   â”œâ”€â”€ ğŸ“ src
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ args.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ lib.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ main.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ ops.rs
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ tests.rs
â”‚   â”‚   â”œâ”€â”€ ğŸ“ tests
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ macos_fake_registry_tests.rs
â”‚   â”‚   â””â”€â”€ ğŸ“„ Cargo.toml
â”‚   â”œâ”€â”€ ğŸ“ fontlift-core
â”‚   â”‚   â”œâ”€â”€ ğŸ“ src
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ config.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ journal.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ lib.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ tests.rs
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ validation_ext.rs
â”‚   â”‚   â””â”€â”€ ğŸ“„ Cargo.toml
â”‚   â”œâ”€â”€ ğŸ“ fontlift-platform-mac
â”‚   â”‚   â”œâ”€â”€ ğŸ“ src
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ lib.rs
â”‚   â”‚   â””â”€â”€ ğŸ“„ Cargo.toml
â”‚   â”œâ”€â”€ ğŸ“ fontlift-platform-win
â”‚   â”‚   â”œâ”€â”€ ğŸ“ src
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ lib.rs
â”‚   â”‚   â””â”€â”€ ğŸ“„ Cargo.toml
â”‚   â”œâ”€â”€ ğŸ“ fontlift-python
â”‚   â”‚   â”œâ”€â”€ ğŸ“ src
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ bindings.rs
â”‚   â”‚   â”‚   â”œâ”€â”€ ğŸ“„ lib.rs
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ stub.rs
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ build.rs
â”‚   â”‚   â””â”€â”€ ğŸ“„ Cargo.toml
â”‚   â””â”€â”€ ğŸ“ fontlift-validator
â”‚       â”œâ”€â”€ ğŸ“ src
â”‚       â”‚   â””â”€â”€ ğŸ“„ main.rs
â”‚       â””â”€â”€ ğŸ“„ Cargo.toml
â”œâ”€â”€ ğŸ“ examples
â”‚   â””â”€â”€ ğŸ“„ basic_usage.rs
â”œâ”€â”€ ğŸ“ issues
â”œâ”€â”€ ğŸ“ python
â”‚   â”œâ”€â”€ ğŸ“ fontlift
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ __init__.py
â”‚   â”‚   â”œâ”€â”€ ğŸ“„ cli.py
â”‚   â”‚   â””â”€â”€ ğŸ“„ render.py
â”‚   â””â”€â”€ ğŸ“ tests
â”‚       â”œâ”€â”€ ğŸ“„ conftest.py
â”‚       â”œâ”€â”€ ğŸ“„ test_import.py
â”‚       â””â”€â”€ ğŸ“„ test_render.py
â”œâ”€â”€ ğŸ“ target
â”‚   â”œâ”€â”€ ğŸ“ debug
â”‚   â”‚   â”œâ”€â”€ ğŸ“ deps
â”‚   â”‚   â”œâ”€â”€ ğŸ“ examples
â”‚   â”‚   â””â”€â”€ ğŸ“ incremental
â”‚   â”‚       â”œâ”€â”€ ğŸ“ _native-2se6nsikgohnc
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ s-hds0214o46-1mc1sxh-0n1ltb0515woxb8vsjswtcrme
â”‚   â”‚       â”œâ”€â”€ ğŸ“ build_script_build-3fwpnf4enr75f
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ s-hds01xzyip-15e8dns-8d36sjrlhdyrfsdzx91u6pejo
â”‚   â”‚       â”œâ”€â”€ ğŸ“ fontlift-1535obyka82s4
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ s-hds01wx23p-1ln41wv-5wo5wfy1pbgr0cg82yju5ch1m
â”‚   â”‚       â”œâ”€â”€ ğŸ“ fontlift_cli-2t49e8p5tkxt7
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ s-hds01wr3wj-0pv4sis-3j9jss0xncw7d7hn335rfycwk
â”‚   â”‚       â”œâ”€â”€ ğŸ“ fontlift_core-03l38ynx1jftr
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ s-hds01uupvg-088ghk3-c64dr68tw6d5p9hb757vy2qbc
â”‚   â”‚       â”œâ”€â”€ ğŸ“ fontlift_core-1q3h5eqs3fcm0
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ s-hds01zyvqi-1tsxpi2-8ly10u3olpbb5n32gawduyfto
â”‚   â”‚       â”œâ”€â”€ ğŸ“ fontlift_core-3m2o36hyimxft
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ s-hds01vznmn-10uwz45-4fs97mgaqc5hc6ipp2jpyc2pd
â”‚   â”‚       â”œâ”€â”€ ğŸ“ fontlift_platform_mac-02u8zx6wplend
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ s-hds01w4boq-0071nts-23a1ba27plzvf419gkqj4u3gw
â”‚   â”‚       â”œâ”€â”€ ğŸ“ fontlift_platform_mac-03oxzcqrba6yl
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ s-hdszee6ske-1deerpq-cl9854y62snieu0kyhammn3bk
â”‚   â”‚       â”œâ”€â”€ ğŸ“ fontlift_platform_mac-0gqjjemgqveco
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ s-hds01vseib-0qe3rmq-2pqy3ffxnphysinr6jntx2ig3
â”‚   â”‚       â”œâ”€â”€ ğŸ“ fontlift_platform_mac-0r67r2a76d67s
â”‚   â”‚       â”‚   â””â”€â”€ ğŸ“ s-hdszee6skg-0fij3e0-2l3ayka9re0ntndqv6cqpx6zr
â”‚   â”‚       â””â”€â”€ ğŸ“ fontlift_platform_mac-32zp9r15uw3zl
â”‚   â”‚           â””â”€â”€ ğŸ“ s-hds0203viw-0ot9dhg-dka5ldqut0efszsdv3hpwwivb
â”‚   â”œâ”€â”€ ğŸ“ maturin
â”‚   â”œâ”€â”€ ğŸ“ release
â”‚   â”‚   â”œâ”€â”€ ğŸ“ deps
â”‚   â”‚   â”œâ”€â”€ ğŸ“ examples
â”‚   â”‚   â””â”€â”€ ğŸ“ incremental
â”‚   â””â”€â”€ ğŸ“ wheels
â”œâ”€â”€ ğŸ“ tests
â”‚   â”œâ”€â”€ ğŸ“ fixtures
â”‚   â”‚   â”œâ”€â”€ ğŸ“ fonts
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ malformed.ttf
â”‚   â”‚   â”œâ”€â”€ ğŸ“ golden_outputs
â”‚   â”‚   â”‚   â””â”€â”€ ğŸ“„ list_json_schema.json
â”‚   â”‚   â””â”€â”€ ğŸ“„ README.md
â”‚   â”œâ”€â”€ ğŸ“„ integration_tests.rs
â”‚   â””â”€â”€ ğŸ“„ test_fonts.rs
â”œâ”€â”€ ğŸ“„ .gitignore
â”œâ”€â”€ ğŸ“„ build.sh
â”œâ”€â”€ ğŸ“„ Cargo.toml
â”œâ”€â”€ ğŸ“„ CLAUDE.md
â”œâ”€â”€ ğŸ“„ FEATURE_MATRIX.md
â”œâ”€â”€ ğŸ“„ IMPROVE--fontlift.md
â”œâ”€â”€ ğŸ“„ LICENSE
â”œâ”€â”€ ğŸ“„ PLAN.md
â”œâ”€â”€ ğŸ“„ publish.sh
â”œâ”€â”€ ğŸ“„ pyproject.toml
â”œâ”€â”€ ğŸ“„ README.md
â”œâ”€â”€ ğŸ“„ RELEASE_CHECKLIST.md
â”œâ”€â”€ ğŸ“„ SECURITY_CONSIDERATIONS.md
â”œâ”€â”€ ğŸ“„ TODO.md
â””â”€â”€ ğŸ“„ USAGE.md


## .github/workflows/ci.yml
```yaml
name: CI

on:
  push:
    branches:
      - main
  pull_request:

env:
  CARGO_TERM_COLOR: always
  PYO3_PYTHON: python

jobs:
  test:
    name: test-${{ matrix.os }}
    strategy:
      matrix:
        os: [macos-14, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install uv and Python deps
        run: |
          python -m pip install --upgrade pip uv
          uv pip install --system maturin pytest fire

      - uses: actions-rust-lang/setup-rust-toolchain@v1
        with:
          toolchain: stable
          components: rustfmt, clippy

      - name: Cargo fmt
        run: cargo fmt --all -- --check

      - name: Cargo clippy
        shell: bash
        run: |
          if [ "$RUNNER_OS" = "Windows" ]; then
            cargo clippy --workspace --all-targets --exclude fontlift-platform-mac -- -D warnings
          else
            cargo clippy --workspace --all-targets --exclude fontlift-platform-win -- -D warnings
          fi

      - name: Cargo test
        shell: bash
        run: |
          if [ "$RUNNER_OS" = "Windows" ]; then
            cargo test --workspace --exclude fontlift-platform-mac --exclude fontlift-python
          else
            cargo test --workspace --exclude fontlift-platform-win --exclude fontlift-python
          fi

      - name: Build Python extension
        shell: bash
        run: |
          # Use uv pip install -e . which triggers hatch-pyo3-plugin to build properly
          uv pip install --system -e .

      - name: Python tests
        shell: bash
        run: pytest python/tests -v
```

## .github/workflows/release.yml
```yaml
name: Release

on:
  push:
    tags:
      - "v*.*.*"

env:
  CARGO_TERM_COLOR: always

jobs:
  build:
    name: build-${{ matrix.os }}
    strategy:
      matrix:
        os: [ubuntu-latest, macos-14, windows-latest]
    runs-on: ${{ matrix.os }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install hatch toolchain
        run: pip install --upgrade pip hatchling hatchling-pyo3 hatch-vcs fire

      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Build Rust CLI
        run: cargo build -p fontlift-cli --release

      - name: Build Python wheel
        run: hatch build -t wheel

      - name: Upload wheels
        uses: actions/upload-artifact@v4
        with:
          name: wheel-${{ matrix.os }}
          path: dist/*.whl

      - name: Upload CLI binary
        uses: actions/upload-artifact@v4
        with:
          name: cli-${{ matrix.os }}
          path: |
            target/release/fontlift*

  publish:
    needs: build
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/v')
    env:
      PYPI_API_TOKEN: ${{ secrets.PYPI_API_TOKEN }}
      CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install hatch toolchain
        run: pip install --upgrade pip hatchling hatchling-pyo3 hatch-vcs

      - name: Ensure tag matches workspace version
        run: |
          python - <<'PY'
import tomllib, os, sys
tag = os.environ["GITHUB_REF"].split("/")[-1]
version = tag.removeprefix("v")
with open("Cargo.toml", "rb") as f:
    data = tomllib.load(f)
workspace_version = data["workspace"]["package"]["version"]
if workspace_version != version:
    sys.stderr.write(f"Tag {version} does not match Cargo workspace version {workspace_version}\n")
    sys.exit(1)
PY

      - uses: actions-rs/toolchain@v1
        with:
          toolchain: stable
          override: true

      - name: Download wheels
        uses: actions/download-artifact@v4
        with:
          pattern: wheel-*
          path: dist
          merge-multiple: true

      - name: Publish to PyPI
        if: env.PYPI_API_TOKEN != ''
        uses: pypa/gh-action-pypi-publish@v1.9.0
        with:
          password: ${{ secrets.PYPI_API_TOKEN }}
          packages_dir: dist

      - name: Publish crates.io
        if: env.CARGO_REGISTRY_TOKEN != ''
        run: |
          cargo publish -p fontlift-core
          cargo publish -p fontlift-platform-mac
          cargo publish -p fontlift-platform-win
          cargo publish -p fontlift-cli
          cargo publish -p fontlift-python
```

## .gitignore
```
# Generated by Cargo
# will have compiled files and executables
debug
target

# These are backup files generated by rustfmt
**/*.rs.bk

# MSVC Windows builds of rustc generate these, which store debugging information
*.pdb

# Generated by cargo mutants
# Contains mutation testing data
**/mutants.out*/

# RustRover
#  JetBrains specific template is maintained in a separate JetBrains.gitignore that can
#  be found at https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore
#  and can be added to the global gitignore or merged into this file.  For a more nuclear
#  option (not recommended) you can uncomment the following to ignore the entire idea folder.
#.idea/

# Python build artifacts
dist/
.hatch/
.venv/
```

## CLAUDE.md
````markdown
# Development Guidelines

## Quick-Start Checklist

**For every task, follow this baseline:**

1. [ ] Read `README.md`, `PLAN.md`, `TODO.md`, `WORK.md` to understand context
2. [ ] Apply Chain-of-Thought: "Let me think step by step..."
3. [ ] Search when <90% confident (codebase, references, web)
4. [ ] Check if this problem has been solved before (packages > custom code)
5. [ ] Write the test FIRST, then minimal code to pass
6. [ ] Test edge cases (empty, None, negative, huge inputs)
7. [ ] Run full test suite after changes
8. [ ] Update documentation (`WORK.md`, `CHANGELOG.md`)
9. [ ] Self-correct: "Wait, but..." and critically review
10. [ ] Delete rather than add when possible

## Normative Language Convention

- **MUST** â€“ Hard requirements, no exceptions
- **SHOULD** â€“ Default behavior; deviate only with clear justification  
- **MAY** â€“ Optional practices or suggestions

---

## I. OPERATING MODEL

You are a Senior Software Engineer obsessed with ruthless minimalism, absolute accuracy, and rigorous verification. You are skeptical of complexity, assumptions, and especially your own first instincts.

### 1.1 Enhanced Chain-of-Thought Process (MUST)

Before ANY response, apply this three-phase thinking:

1. **Analyze** â€“ "Let me think step by step..."
   - Deconstruct the request completely
   - Identify constraints and edge cases
   - Question implicit assumptions

2. **Abstract (Step-Back)** â€“ Zoom out before diving in
   - What high-level patterns apply?
   - What are 2-3 viable approaches?
   - What are the trade-offs?

3. **Execute** â€“ Select the most minimal, verifiable path
   - Your output MUST be what you'd produce after finding and fixing three critical issues

### 1.2 Communication: Anti-Sycophancy (MUST)

**Accuracy is non-negotiable. Facts over feelings.**

- **NEVER** use validation phrases: "You're right", "Great idea", "Exactly"
- **ALWAYS** challenge incorrect statements immediately with "Actually, that's incorrect because..."
- **MUST** state confidence explicitly:
  - "I'm certain (>95% confidence)"
  - "I believe (70-95% confidence)" 
  - "This is an educated guess (<70% confidence)"
- When <90% confident, **MUST** search before answering
- LLMs can hallucinate â€“ treat all outputs (including your own) with skepticism

### 1.3 Mandatory Self-Correction Phase (MUST)

After drafting any solution:

1. Say "Wait, but..." and critique ruthlessly
2. Check: Did I add unnecessary complexity? Are there untested assumptions? 
3. Revise based on the critique before delivering

### 1.4 Context Awareness (SHOULD)

- **FREQUENTLY** state which project/directory you're working in
- **ALWAYS** explain the WHY behind changes
- No need for manual `this_file` tracking â€“ that's impractical overhead

---

## II. CORE PHILOSOPHY

### 2.1 The Prime Directive: Ruthless Minimalism (MUST)

**Complexity is debt. Every line of code is a liability.**

- **YAGNI**: Build only what's required NOW
- **Delete First**: Can we remove code instead of adding?
- **One-Sentence Scope**: Define project scope in ONE sentence and reject everything else

### 2.2 Build vs Buy (MUST Prefer Buy)

**Package-First Workflow:**

1. **Search** existing solutions (PyPI, npm, crates.io, GitHub)
2. **Evaluate** packages: >1000 stars, recent updates, good docs, minimal deps
3. **Prototype** with a small PoC to verify
4. **Use** the package â€“ only write custom code if no suitable package exists

### 2.3 Test-Driven Development (MUST)

**Untested code is broken code.**

1. **RED** â€“ Write a failing test first
2. **GREEN** â€“ Write minimal code to pass
3. **REFACTOR** â€“ Clean up while keeping tests green
4. **VERIFY** â€“ Test edge cases, error conditions, integration

### 2.4 Complexity Triggers â€“ STOP Immediately If You See:

- "General purpose" utility functions
- Abstractions for "future flexibility"
- Custom parsers, validators, formatters
- Any Manager/Handler/System/Framework class
- Functions >20 lines, Files >200 lines, >3 indentation levels
- Security hardening, performance monitoring, analytics

---

## III. STANDARD OPERATING PROCEDURE

### 3.1 Before Starting (MUST)

1. Read `README.md`, `WORK.md`, `CHANGELOG.md`, `PLAN.md`, `TODO.md`
2. Run existing tests to understand current state
3. Apply Enhanced CoT (Analyze â†’ Abstract â†’ Execute)
4. Search for existing solutions before writing code

### 3.2 During Work â€“ Baseline Mode (MUST)

For **every** change:

1. Write test first
2. Implement minimal code
3. Run tests
4. Document in `WORK.md`

### 3.3 During Work â€“ Enhanced Mode (SHOULD for major changes)

For significant features or risky changes:

1. All baseline steps PLUS:
2. Test all edge cases comprehensively
3. Test error conditions (network, permissions, missing files)
4. Performance profiling if relevant
5. Security review if handling user input
6. Update all related documentation

### 3.4 After Work (MUST)

1. Run full test suite
2. Self-correction phase: "Wait, but..."
3. Update `CHANGELOG.md` with changes
4. Update `TODO.md` status markers
5. Verify nothing broke

---

## IV. LANGUAGE-SPECIFIC GUIDELINES

### 4.1 Python

#### Modern Toolchain (MUST)

- **Package Management**: `uv` exclusively (not pip, not conda)
- **Python Version**: 3.12+ via `uv` (never system Python)
- **Virtual Environments**: Always use `uv venv`
- **Formatting & Linting**: `ruff` (replaces black, flake8, isort, pyupgrade)
- **Type Checking**: `mypy` or `pyright` (mandatory for all code)
- **Testing**: `pytest` with `pytest-cov`, `pytest-randomly`

#### Project Setup (SHOULD)

```bash
uv venv --python 3.12
uv init
uv add fire rich loguru httpx pydantic pytest pytest-cov
```

#### Project Layout (SHOULD)

```
project/
â”œâ”€â”€ src/
â”‚   â””â”€â”€ package_name/
â”œâ”€â”€ tests/
â”œâ”€â”€ pyproject.toml
â””â”€â”€ README.md
```

#### Core Packages to Prefer (SHOULD)

- **CLI**: `typer` or `fire` + `rich` for output
- **HTTP**: `httpx` (not requests)
- **Data Validation**: `pydantic` v2
- **Logging**: `loguru` or `structlog` (structured logs)
- **Async**: `asyncio` with `FastAPI` for web
- **Data Formats**: JSON, SQLite, Parquet (not CSV for production)
- **Config**: Environment variables or TOML (via `tomllib`)

#### Code Standards (MUST)

- Type hints on EVERY function
- Docstrings explaining WHAT and WHY
- Use dataclasses or Pydantic for data structures
- `pathlib` for paths (not os.path)
- f-strings for formatting

#### Testing (MUST)

```bash
# Run with coverage
pytest --cov=src --cov-report=term-missing --cov-fail-under=80

# With ruff cleanup
uvx ruff check --fix . && uvx ruff format . && pytest
```

### 4.2 Rust

#### Toolchain (MUST)

- **Build**: `cargo` for everything
- **Format**: `cargo fmt` (no exceptions)
- **Lint**: `cargo clippy -- -D warnings`
- **Security**: `cargo audit` and `cargo deny`

#### Core Principles (MUST)

- **Ownership First**: Leverage the type system to prevent invalid states
- **Minimize `unsafe`**: Isolate, document, and audit any unsafe code
- **Error Handling**: Use `Result<T, E>` everywhere
  - Libraries: `thiserror` for error types
  - Applications: `anyhow` for error context
- **No `panic!` in libraries**: Only in truly unrecoverable situations

#### Concurrency (SHOULD)

- **Async Runtime**: `tokio` (default choice)
- **HTTP**: `reqwest` or `axum`
- **Serialization**: `serde` with `serde_json`
- **CLI**: `clap` with derive macros
- **Logging**: `tracing` with `tracing-subscriber`

#### Security (MUST)

- Enable integer overflow checks in debug
- Validate ALL external input
- Use `cargo-audit` in CI
- Prefer safe concurrency primitives (`Arc`, `Mutex`) 
- Use vetted crypto crates only (`ring`, `rustls`)

### 4.3 Web Development

#### Frontend (TypeScript/React)

##### Toolchain (MUST)

- **Package Manager**: `pnpm` (not npm, not yarn)
- **Bundler**: `vite` 
- **TypeScript**: `strict: true` in tsconfig.json
- **Framework**: Next.js (React) or SvelteKit (Svelte)
- **Styling**: Tailwind CSS
- **State**: Local state first, then Zustand/Jotai (avoid Redux)

##### Core Requirements (MUST)

- **Mobile-First**: Design for mobile, enhance for desktop
- **Accessibility**: WCAG 2.1 AA compliance minimum
- **Performance**: Optimize Core Web Vitals (LCP < 2.5s, FID < 100ms)
- **Security**: Sanitize inputs, implement CSP headers
- **Type Safety**: Zod for runtime validation at API boundaries

##### Best Practices (SHOULD)

- Server-side rendering for initial page loads
- Lazy loading for images and components
- Progressive enhancement
- Semantic HTML
- Error boundaries for graceful failures

#### Backend (Node.js/API)

##### Standards (MUST)

- **Framework**: Express with TypeScript or Fastify
- **Validation**: Zod or Joi for input validation
- **Auth**: Use established libraries (Passport, Auth0)
- **Database**: Prisma or Drizzle ORM
- **Testing**: Vitest or Jest with Supertest

##### Security (MUST)

- Rate limiting on all endpoints
- HTTPS only
- Helmet.js for security headers
- Input sanitization
- SQL injection prevention via parameterized queries

---

## V. PROJECT DOCUMENTATION

### Required Files (MUST maintain)

- **README.md** â€“ Purpose and quick start (<200 lines)
- **CHANGELOG.md** â€“ Cumulative release notes
- **PLAN.md** â€“ Detailed future goals and architecture
- **TODO.md** â€“ Flat task list from PLAN.md with status:
  - `[ ]` Not started
  - `[x]` Completed  
  - `[~]` In progress
  - `[-]` Blocked
  - `[!]` High priority
- **WORK.md** â€“ Current work log with test results
- **DEPENDENCIES.md** â€“ Package list with justifications

---

## VI. SPECIAL COMMANDS

### `/plan [requirement]` (Enhanced Planning)

When invoked, MUST:

1. **Research** existing solutions extensively
2. **Deconstruct** into core requirements and constraints
3. **Analyze** feasibility and identify packages to use
4. **Structure** into phases with dependencies
5. **Document** in PLAN.md with TODO.md checklist

### `/test` (Comprehensive Testing)

**Python:**
```bash
uvx ruff check --fix . && uvx ruff format . && pytest -xvs
```

**Rust:**
```bash
cargo fmt --check && cargo clippy -- -D warnings && cargo test
```

**Then** perform logic verification on changed files and document in WORK.md

### `/work` (Execution Loop)

1. Read TODO.md and PLAN.md
2. Write iteration goals to WORK.md
3. **Write tests first**
4. Implement incrementally
5. Run /test continuously
6. Update documentation
7. Continue to next item

### `/report` (Progress Update)

1. Analyze recent changes
2. Run full test suite
3. Update CHANGELOG.md
4. Clean up completed items from TODO.md

---

## VII. LLM PROMPTING PATTERNS

### Chain-of-Thought (CoT)

For complex reasoning tasks, ALWAYS use:
```
"Let me think step by step...
1. First, I need to...
2. Then, considering...
3. Therefore..."
```

### ReAct Pattern (for Tool Use)

When using external tools:
```
Thought: What information do I need?
Action: [tool_name] with [parameters]
Observation: [result]
Thought: Based on this, I should...
```

### Self-Consistency

For critical decisions:
1. Generate multiple solutions
2. Evaluate trade-offs
3. Select best approach with justification

### Few-Shot Examples

When generating code/tests, provide a minimal example first:
```python
# Example test pattern:
def test_function_when_valid_input_then_expected_output():
    result = function(valid_input)
    assert result == expected, "Clear failure message"
```

---

## VIII. ANTI-BLOAT ENFORCEMENT

### Scope Discipline (MUST)

Define scope in ONE sentence. Reject EVERYTHING else.

### RED LIST â€“ NEVER Add Unless Explicitly Required:

- Analytics/metrics/telemetry
- Performance monitoring/profiling  
- Production error frameworks
- Advanced security beyond input validation
- Health monitoring/diagnostics
- Circuit breakers/sophisticated retry
- Complex caching systems
- Configuration validation frameworks
- Backup/recovery mechanisms
- Benchmarking suites

### GREEN LIST â€“ Acceptable Additions:

- Basic try/catch error handling
- Simple retry (â‰¤3 attempts)
- Basic logging (print or loguru)
- Input validation for required fields
- Help text and examples
- Simple config files (TOML)
- Core functionality tests

### Complexity Limits (MUST)

- Simple utilities: 1-3 commands
- Standard tools: 4-7 commands  
- Over 8 commands: Probably over-engineered
- Could fit in one file? Keep it in one file
- Weekend rewrite test: If it takes longer, it's too complex

---

# IX. PROSE WRITING

## Hook and hold

- **First line sells the second line** â€“ No throat-clearing
- **Enter late, leave early** â€“ Start in action, end before over-explaining
- **Conflict creates interest** â€“ What's at stake?

## Clarity above all

- **Embrace plain language** â€“ Never use "utilize" when "use" works. Clarity is kindness to your reader
- **No corporate jargon** â€“ Clear, concrete language only
- **Use active voice and strong verbs** â€“ "John slammed the door" beats "The door was slammed by John"
- **Omit needless words** â€“ Every sentence should either reveal character or advance action. If it doesn't, cut it

## Show, donâ€™t tell

- **Show through action, not exposition** â€“ Instead of "Sarah was nervous," write "Sarah picked at her cuticles until they bled"
- **Use specific details, not generic descriptions** â€“ "A 1973 Plymouth Duster with a cracked windshield" beats "an old car"
- **Trust the reader's intelligence** â€“ Stop explaining what you've just shown. Your reader doesn't need training wheels

## Focus your impact

- **One person, one problem** â€“ Specific beats generic
- **Write for one reader, not everyone** â€“ Pick your ideal reader and ignore everyone else
- **Transformation over features** â€“ Show the change, not the tool

## Edit without mercy

- **Kill your darlings** â€“ If it doesn't serve the reader, delete it
- **Skepticism is healthy** â€“ Question everything, including this guide
- **Light humor allowed** â€“ But clarity comes first

## Sell gently

- **Pain before gain** â€“ Start with the problem they feel today, not the solution you're selling
- **Benefits trump features** â€“ "Sleep through the night" beats "memory foam with 3-inch density"
- **Social proof early** â€“ Third-party validation in the first third builds trust faster than any claim

## Explain clearly

- **Lead with the outcome** â€“ Tell them what they'll accomplish before how to accomplish it
- **Progressive disclosure** â€“ Basic usage first, advanced options later, edge cases last
- **Error messages are UX** â€“ Write them like helpful directions, not system diagnostics

**The golden rule**: If the reader has to read it twice, you've failed once.


---

**Remember: The best code is no code. The second best is someone else's well-tested code. Write as little as possible, test everything, and delete ruthlessly.**
````

## Cargo.toml
```toml
[workspace]
resolver = "2"
members = [
  "crates/fontlift-cli",
  "crates/fontlift-core",
  "crates/fontlift-platform-mac",
  "crates/fontlift-platform-win",
  "crates/fontlift-python",
  "crates/fontlift-validator",
]

[workspace.package]
version = "2.0.0-dev"
authors = ["FontLab Ltd."]
edition = "2021"
rust-version = "1.75"
repository = "https://github.com/fontlaborg/fontlift"
license = "Apache-2.0"

[workspace.dependencies]
anyhow = "1.0"
clap = { version = "4.0", features = ["derive"] }
clap_complete = "4.5"
env_logger = "0.11"
# CLI and Python crates
fontlift-cli = { path = "crates/fontlift-cli" }
# Core crates
fontlift-core = { path = "crates/fontlift-core" }
# Platform crates
fontlift-platform-mac = { path = "crates/fontlift-platform-mac" }
fontlift-platform-win = { path = "crates/fontlift-platform-win" }
fontlift-python = { path = "crates/fontlift-python" }
fontlift-validator = { path = "crates/fontlift-validator" }
log = "0.4"
read-fonts = "0.26"
uuid = { version = "1.11", features = ["v4", "serde"] }
pyo3 = "0.24.1"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
# External dependencies
thiserror = "2.0"
tokio = { version = "1.0", features = ["full"] }

# Additional dependencies for testing
tempfile = "3.0"
tokio-test = "0.4"

# Platform-specific dependencies (objc2 ecosystem)
objc2 = "0.6"
objc2-foundation = "0.3"
objc2-core-foundation = "0.3"
objc2-core-graphics = "0.3"
objc2-core-text = "0.3"
windows = { version = "0.54", features = [
  "Win32_Foundation",
  "Win32_Graphics_Gdi",
  "Win32_Storage_FileSystem",
  "Win32_System_Registry",
  "Win32_UI_Shell",
] }

# Platform-specific dependencies are defined in individual crates

[profile.dev]
opt-level = 0
debug = true

[profile.release]
opt-level = 3
strip = true
lto = true
codegen-units = 1
```

## FEATURE_MATRIX.md
```markdown
# FontLift Feature Matrix

This document compares the feature set between existing Swift/macOS and C++/Windows implementations with the target unified Rust implementation.

## Existing Implementations Analysis

### Swift/macOS CLI (fontlift-mac-cli)
**Version**: 2.0.0 (production ready)
**Source**: `Sources/fontlift/fontlift.swift` (1,344 lines)

**Core Features**:
- âœ… Font installation (user/system scope)
- âœ… Font uninstallation (user/system scope)
- âœ… Font removal (uninstall + delete)
- âœ… Font listing with multiple output modes
- âœ… Cache cleanup (user/system + third-party)
- âœ… Conflict detection and auto-resolution
- âœ… Safety protections for system fonts
- âœ… Comprehensive file validation
- âœ… Font metadata extraction (PostScript, family names)
- âœ… Shell-safe path handling
- âœ… Fake registration mode for testing

**Advanced Features**:
- âœ… Third-party cache clearing (Adobe, Microsoft Office)
- âœ… Missing font registration pruning
- âœ… Admin privilege handling
- âœ… Comprehensive error messages
- âœ… Simulated mode for testing
- âœ… Environment variable overrides
- âœ… Persistent fake registry

### Windows CLI (fontlift-win-cli)
**Version**: Based on C++ implementation
**Source**: `src/main.cpp` (complete implementation)

**Core Features**:
- âœ… Font installation via Windows Registry
- âœ… Font uninstallation
- âœ… Font listing
- âœ… Registry-based font management
- âœ… Windows GDI integration
- âœ… Admin privilege support

**Platform-Specific Features**:
- âœ… Windows Registry manipulation
- âœ… GDI font notifications
- âœ… Windows font directory management
- âœ… Permission handling

## Target Unified Rust Implementation

### Phase 1 Target Features (MVP Parity)
**Must Have** (Feature Parity with Existing CLIs):
- [x] Font installation (user/system scope)
- [x] Font uninstallation (user/system scope)
- [x] Font removal (uninstall + delete)
- [x] Font listing (paths, names, combined)
- [x] Basic cache cleanup
- [x] File validation (extension, existence, readability)
- [x] System font protection
- [x] Font metadata extraction
- [x] Error handling and reporting

**Platform Implementation**:
- [x] macOS: Core Text APIs
- [~] Windows: Registry + GDI APIs (flows implemented; host validation pending)
- [x] Cross-platform: Trait-based abstractions

### Phase 2 Target Features (Enhanced)
**Should Have** (Quality Improvements):
- [~] Advanced cache cleanup (third-party apps)
- [~] Missing font registration pruning
- [x] Conflict detection and auto-resolution
- [x] Improved error messages and guidance
- [~] Test mode/simulation
- [ ] Configuration file support
- [x] Better privilege handling

**Could Have** (Nice to Have):
- [ ] Font collection support (.ttc/.otc)
- [ ] Batch operations
- [ ] Progress indicators
- [ ] JSON output mode
- [ ] Font validation reports
- [ ] Integration with twasitors/typf

## Implementation Status Matrix

| Feature | Swift/macOS | Windows CLI | Rust Core | Rust macOS | Rust Windows | Status |
|---------|-------------|-------------|-----------|------------|--------------|---------|
| **Core Operations** |
| Font Install | âœ… | âœ… | âœ… | âœ… | ğŸ—ï¸ In Progress | macOS parity validated; Windows path/scopes need host validation |
| Font Uninstall | âœ… | âœ… | âœ… | âœ… | ğŸ—ï¸ In Progress | Windows cross-scope fallback implemented, host validation pending |
| Font Remove | âœ… | âœ… | âœ… | âœ… | ğŸ—ï¸ In Progress | Delete-after-uninstall wired; Windows protection checks need real host |
| Font List | âœ… | âœ… | âœ… | âœ… | ğŸ—ï¸ In Progress | Descriptor/registry metadata implemented; Windows dedupe needs host run |
| **Platform Integration** |
| Core Text (macOS) | âœ… | N/A | âœ… | âœ… | N/A | Complete |
| Registry/GDI (Win) | N/A | âœ… | âœ… | N/A | ğŸ—ï¸ In Progress | Registry + GDI flows implemented; requires on-device verification |
| **Advanced Features** |
| Cache Cleanup | âœ… | âš ï¸ | âœ… | âœ… | ğŸ—ï¸ In Progress | macOS prune/cache toggles + vendor caches done; Windows FontCache/Adobe purge implemented, pending validation |
| System Font Protection | âœ… | âš ï¸ | âœ… | âœ… | âœ… | Enforced in core helpers + platform guards |
| Conflict Detection | âœ… | âŒ | âœ… | âœ… | âœ… | Core dedupe + Windows auto-removal implemented |
| Simulation Mode | âœ… | âŒ | âœ… | âœ… | âŒ | Fake registry + dry-run on macOS; Windows simulation not yet |
| **Quality Features** |
| Error Handling | âœ… | âš ï¸ | âœ… | âœ… | âœ… | Unified error mapping with legacy exit codes |
| CLI Interface | âœ… | âœ… | âœ… | âœ… | âœ… | Aliases, JSON, batch paths, dry-run/quiet/verbose implemented |
| File Validation | âœ… | âš ï¸ | âœ… | âœ… | âœ… | Extension + content validation shared across platforms |

## Legacy CLI Parity Checklist (commands & flags)

| Item | Swift/macOS CLI | Windows CLI | Rust CLI (current) | Gap / Notes |
|------|-----------------|-------------|--------------------|-------------|
| Commands present | `list`, `install`, `uninstall`, `remove`, `cleanup` | same | same | core surface matches |
| Aliases | `l`, `i`, `u`, `rm`; cleanup exposed as `cleanup` only | `l`, `i`, `u`, `rm`, `c` | `l`, `i`, `u`, `rm`, `c` | parity achieved |
| Path flag (`-p/--path`) | yes (list/install/uninstall/remove) | yes (list/install/uninstall/remove) | yes (list/install/uninstall/remove) | parity achieved |
| Name flag (`-n/--name`) | list/uninstall/remove support | list/uninstall/remove support | list/uninstall/remove support | parity achieved |
| Sorted flag (`-s/--sorted`) | yes (list) | yes (list) | yes (list) | parity achieved |
| Scope flag (`--admin/-a`) | install/uninstall/remove/cleanup | all commands | all commands | parity achieved |
| Cleanup toggles | `--prune-only`, `--cache-only`; clears Adobe/Microsoft caches | none; cleanup always prunes + clears caches (user, `--admin` for system) | `--prune-only`, `--cache-only`; vendor cache purge on macOS + Windows implemented | Windows host validation pending |
| Conflict handling | detection + auto-resolve; fake registry mode for tests | auto-removes existing family on install | detection + auto-resolve; macOS fake registry + dry-run | Windows fake registry still pending |
| Batch/collection handling | `.ttc/.otc`; docs encourage directory loops | `.ttc/.otc`; no directory helper | `.ttc/.otc` accepted; directory expansion for install/uninstall/remove | parity achieved |
| Output modes | path, name, `path::name`; shell-safe escaping | path, name, both; sorted option | deterministic list output; JSON + path/name toggles | shell-escape parity not yet targeted |
| Exit codes | `0` success, `1` failure | `0` success, `1` error, `2` permission denied | `0` success; permission-denied mapped to exit 1 | consider exit code 2 for denied parity |
| Simulation/dry-run | env-driven fake registry + dry-run guidance | none | macOS fake registry + CLI dry-run | Windows simulation not yet |

**Legend**:
- âœ… Complete/Implemented
- ğŸ“ In Progress/Partially Implemented
- ğŸ“‹ Planned/Designed
- âŒ Not Available
- âš ï¸ Limited Implementation
- N/A Not Applicable

## Success Metrics

### Functional Metrics
- âœ… **API Parity**: 100% of core operations available across platforms
- âœ… **Feature Coverage**: All essential features from existing CLIs implemented
- âœ… **Cross-Platform**: Identical behavior on macOS and Windows
- âœ… **Integration**: Seamless integration with typf/testypf ecosystems

### Quality Metrics
- âœ… **Test Coverage**: >90% test coverage for all functionality
- âœ… **Error Handling**: Comprehensive error messages with actionable guidance
- âœ… **Performance**: Operations complete within acceptable timeframes
- âœ… **Safety**: No accidental system font modifications
- âœ… **Documentation**: Complete API and usage documentation

### Integration Metrics
- âœ… **CLI Consistency**: Same command structure across platforms
- âœ… **Library Integration**: Clean Rust API for other projects
- âœ… **Bindings Support**: Python bindings ready for twasitors
- âœ… **Future Compatibility**: Extensible architecture for new platforms

## Implementation Roadmap

### Phase 0: Alignment âœ… COMPLETE
- [x] Analyze existing implementations
- [x] Create feature matrix
- [x] Define success metrics
- [x] Document architectural decisions

### Phase 1: Architectural Foundations (Current)
- [x] Design crate structure
- [x] Specify FontManager trait
- [x] Define error handling strategy
- [x] Implement core validation utilities
- [~] Complete platform-specific implementations
- [x] Basic CLI with essential commands

### Phase 2: Feature Completion
- [~] Complete all core operations
- [~] Implement advanced cache management
- [x] Add conflict detection
- [x] Enhance error messages
- [~] Add simulation/testing mode

### Phase 3: Integration & Polish
- [~] Python bindings integration
- [x] CLI feature completeness
- [~] Documentation completion
- [ ] Performance optimization
- [~] Cross-platform testing

### Phase 4: Production Ready
- [ ] Comprehensive test suite
- [ ] Release documentation
- [ ] Integration testing with typf/testypf
- [ ] Performance benchmarks
- [ ] Security audit

---

**Status**: Phase 0 Complete, Phase 1 In Progress
**Next**: Complete core platform implementations and CLI functionality
```

## IMPROVE--fontlift.md
````markdown
Hereâ€™s what I see (high confidence): there *is* breakthrough potential, primarily in **security/robustness**, not raw performance. Font management is mostly I/O + OS calls, so big speedups are limited, but we *can* make the system significantly safer and more failureâ€‘resistant in ways most tools donâ€™t bother with. 

Below is a concrete, implementable plan.

---

## Breakthrough 1 â€” Outâ€‘ofâ€‘process, resourceâ€‘bounded font validation pipeline

### Why this is a real upgrade

Right now, validation is basically:

* Check path exists, is a file, has a â€œfontyâ€ extension, can read metadata. 

The OS font stack (Core Text / Windows GDI) still ends up parsing arbitrary font bytes, which is historically a rich source of memoryâ€‘safety bugs. You already sketched a richer `FontValidator` / `SecureFontRegistration` in `SECURITY_CONSIDERATIONS.md` but itâ€™s not wired into the real code. 

A **sandboxed validator process** that uses `read-fonts` to parse fonts and enforce limits before the OS ever sees them is a genuine defenseâ€‘inâ€‘depth improvement and makes the whole system meaningfully safer without depending on the OSâ€™ own parsing quality.

### Highâ€‘level design

**Goal:** All â€œdangerousâ€ parsing and inspection of untrusted font files happens in a separate, shortâ€‘lived, resourceâ€‘limited helper process.

1. **New helper binary:** `fontlift-validator`

   * Small Rust binary living in a new crate (e.g. `crates/fontlift-validator`), depending on `fontlift-core` and `read-fonts`. 
   * Accepts:

     * A list of paths
     * Optional config (max size, allowed formats, strictness) via CLI flags or a small JSON stdin blob.
   * Produces:

     * JSON array of `{ ok: bool, info?: FontliftFontFaceInfo, error?: String }`.

2. **Validator responsibilities (inside helper process)**

   * Enforce **basic constraints**:

     * Max file size (e.g. default 64 MB, configurable).
     * Extension & MIME sniffing (using `read-fonts` to actually open, not just extension). 
   * Parse fonts with `read-fonts`:

     * Verify the file is structurally sane.
     * Extract PostScript name, family, style, weight, italic, etc., to build `FontliftFontFaceInfo` instead of filename heuristics. 
   * Enforce **resource limits**:

     * Use `std::thread::spawn` with a watchdog timer and `std::process::exit` if parsing hangs.
     * Optionally accept a `--timeout-ms` flag and kill operations exceeding that time.
   * Return a *sanitized* error string (no internal paths or stack traces).

3. **Sandboxing / privilege reduction (per platform)**

   Start simple (just a separate process; still a huge win), then harden:

   * **macOS**:

     * Drop privileges where possible (run validator as the same user but with no privileged operations).
     * Optional: use a `sandbox-exec` profile or a dedicated helper binary with **no network** access and readâ€‘only access to the specific font files (via `posix_spawn` with chroot/jail, if you want to go deep later).
   * **Windows**:

     * Use a separate process launched with a **restricted token** and a Job Object limiting memory & CPU (if/when you implement that; can be phase 2).
   * **Abstraction:** In `fontlift-core`, define a small â€œvalidator backendâ€ (enum or trait) with platformâ€‘specific `spawn_validator(paths, config)`.

Regardless of how strong the OS sandboxing is, just moving parsing into a helper process prevents a corrupt font from bringing down (or confusing) the main CLI/daemon.

### How to integrate into existing code

#### 1. Core API changes

In `fontlift-core`:

* Add a new module, e.g. `validation_ext`:

```rust
pub struct ValidatorConfig {
    pub max_file_size_bytes: u64,
    pub timeout_ms: u64,
    pub allow_collections: bool,
    // future: allowlist formats, etc.
}

pub fn validate_and_introspect(
    paths: &[PathBuf],
    config: &ValidatorConfig,
) -> FontResult<Vec<Result<FontliftFontFaceInfo, FontError>>> {
    // 1. Spawn `fontlift-validator` child process.
    // 2. Send paths/config (JSON over stdin).
    // 3. Read JSON response.
    // 4. Map into FontliftFontFaceInfo / FontError.
}
```

* Expose a stricter version of `validate_font_file` that goes through the helper instead of just checking extension/existence. 

#### 2. macOS install path

In `MacFontManager::install_font` (where you currently:

* validate extension/existence,
* copy to target dir,
* register via Core Text), 

insert:

1. Early call to `validate_and_introspect(&[source.path.clone()], &ValidatorConfig { â€¦ })`.
2. If validation fails, **abort** before copying or registering, and surface a clean `FontError::InvalidFormat` with a userâ€‘friendly message.
3. If validation succeeds, cache the returned `FontliftFontFaceInfo`:

   * Use it for conflict detection (duplicate names, etc.) instead of relying solely on Core Text / heuristics.

This uses your existing conflict helper (`conflicts::detect_conflicts`) but with *richer, validated metadata* instead of filename heuristics. 

#### 3. Windows path

When you flesh out `WinFontManager`:

* Reuse the same validator pipeline for:

  * Install (preâ€‘flight check fonts).
  * List (you could use readâ€‘fonts meta instead of registry name tables when possible).
  * Cleanup (detect obviously corrupt/orphaned files before messing with registry).

#### 4. Python bindings & CLI

* For Python (`fontlift-python` + `python/fontlift`): 

  * Expose a `strict: bool` or `validation_config: dict | None` argument on public APIs (`install`, `cleanup`) and route those through `validate_and_introspect`.
  * Document in Python docstring that `strict=True` performs full parsing and denies malformed fonts.

* For CLI:

  * Add global flags:

    * `--no-validate` (default: validate on install).
    * `--validation-strictness {lenient,normal,paranoid}` mapping to ValidatorConfig presets.
  * For batch installs, run validation in batches (not one process per file) to amortize overhead.

### Testing & verification

1. **Unit tests**

   * Add tests that feed knownâ€‘bad font samples (tiny fuzzerâ€‘generated fonts) to `fontlift-validator` and assert:

     * It exits cleanly with a friendly error.
     * Main process receives error and does not crash.
   * Add tests for max size / timeout behaviour with dummy files.

2. **Integration tests**

   * In `tests/`, add:

     * A â€œmalformed fontâ€ fixture (or just a random binary with `.ttf` extension).
     * Integration test: run CLI `fontlift install` on that file and assert it fails with `InvalidFormat` and does not attempt Core Text registration.

3. **Performance sanity**

   * Benchmark `install` for:

     * Single font.
     * Batch of ~100 fonts.
   * Compare before/after. If overhead is too large, consider:

     * Reusing a single longâ€‘running validator process (via a simple RPC protocol).
     * Parallelizing validation across cores.

---

## Breakthrough 2 â€” Transactional, crashâ€‘safe install/remove with a tiny operation journal

### Why this helps

Install/remove/cleanup on macOS already involve multiple steps: copy file, register/unregister via Core Text, clear caches vendorâ€‘side, etc. 

If the process dies midway (power loss, segfault, kill â€‘9), you can end up in annoying states:

* File copied but never registered â†’ user sees a â€œmysteryâ€ font file that doesnâ€™t appear in app font lists.
* Registered but file missing â†’ ghost entries until cleanup/prune is run.
* Partial cleanup â†’ caches inconsistent.

You already have `prune_missing_fonts` and cleanup logic, but itâ€™s *reactive* and not tightly bound to specific operations. A small **operation journal** makes install/remove semantics much stronger:

> Either the operation fully completed, or we know exactly what step it died at and can autoâ€‘fix next run.

This is especially valuable if FontLift becomes a longâ€‘running service or is invoked from automation.

### Design overview

1. **Operation journal format (core)**

In `fontlift-core`, create something like:

```rust
#[derive(Serialize, Deserialize)]
pub enum JournalAction {
    CopyFile { from: PathBuf, to: PathBuf },
    RegisterFont { path: PathBuf, scope: FontScope },
    UnregisterFont { path: PathBuf, scope: FontScope },
    DeleteFile { path: PathBuf },
    ClearCache { scope: FontScope },
}

#[derive(Serialize, Deserialize)]
pub struct JournalEntry {
    pub id: uuid::Uuid,
    pub started_at: SystemTime,
    pub completed: bool,
    pub actions: Vec<JournalAction>,
    pub current_step: usize, // index into `actions`
}
```

* Store entries in a small JSON file under:

  * macOS: `~/Library/Application Support/FontLift/journal.json` (or under the fake root during tests).
  * Windows: `%LOCALAPPDATA%\FontLift\journal.json`. 

2. **Helpers**

Core functions:

```rust
pub fn journal_path() -> PathBuf { /* platform-specific */ }

pub fn load_journal() -> Vec<JournalEntry> { /* read + parse or default */ }

pub fn save_journal(entries: &[JournalEntry]) -> FontResult<()> { /* atomic write */ }

pub fn record_operation(actions: Vec<JournalAction>) -> FontResult<JournalEntry> { /* append */ }

pub fn mark_step(entry_id: Uuid, step_index: usize) -> FontResult<()> { /* update */ }

pub fn mark_completed(entry_id: Uuid) -> FontResult<()> { /* update */ }
```

Use an atomic write pattern (write to `journal.json.tmp` then `rename`) to avoid corruption.

3. **Crash recovery**

Add a core function:

```rust
pub fn recover_incomplete_operations<F>(manager: &dyn FontManager, handler: F) -> FontResult<()>
where
    F: Fn(&JournalEntry, &JournalAction) -> FontResult<()>,
{
    // For each incomplete entry:
    //  - From current_step..actions.len(), either roll forward or roll back.
}
```

Policy choice per action:

* **CopyFile**:

  * If `to` exists and matches expected size/hash â†’ assume copy done; move to next.
  * If `to` missing / mismatched â†’ delete and redo copy or roll back.
* **RegisterFont**:

  * Check `is_font_installed`; if not, reâ€‘attempt registration.
* **UnregisterFont**:

  * If `is_font_installed` false, treat as done; else retry unregister.
* **DeleteFile**:

  * If file exists, delete; if not, ok.

You can expose this via:

* CLI: `fontlift doctor` that runs recovery and prints actions taken.
* Automatic: run `recover_incomplete_operations` **at process start** for CLI and Python manager (behind a feature flag if you want).

4. **Wire into macOS `MacFontManager`**

Take `MacFontManager::install_font` and wrap its steps:

Current conceptual steps (simplified): 

1. Validate font.
2. Validate system permissions / scope.
3. Decide target path.
4. (Maybe) copy file.
5. Register with Core Text.

Refactor to:

```rust
fn install_font(&self, source: &FontliftFontSource) -> FontResult<()> {
    let scope = /* ... */;
    let target_path = self.installed_target_path(source, scope)?;
    let mut actions = Vec::new();

    if target_path != source.path {
        actions.push(JournalAction::CopyFile {
            from: source.path.clone(),
            to: target_path.clone(),
        });
    }

    actions.push(JournalAction::RegisterFont {
        path: target_path.clone(),
        scope,
    });

    let entry = record_operation(actions.clone())?;
    let mut step_index = 0;

    for action in &actions {
        match action {
            JournalAction::CopyFile { from, to } => {
                self.copy_font_to_target_directory(from, scope, /* replace_existing */ true)?;
            }
            JournalAction::RegisterFont { path, scope } => {
                self.install_font_core_text(path, *scope)?;
            }
            _ => {}
        }
        step_index += 1;
        mark_step(entry.id, step_index)?;
    }

    mark_completed(entry.id)?;
    Ok(())
}
```

Similar for `remove_font`:

* Actions: `UnregisterFont`, then `DeleteFile`.

For `cleanup` / `prune_missing_fonts`, you probably *donâ€™t* want journal overhead by default, but you can add it for systemâ€‘wide operations or when `--verbose`/`--debug` is used.

5. **Windows integration**

Once `WinFontManager` is implemented, wrap:

* Registry writes/removals.
* GDI notifications.
* File copy / delete steps.

so that incomplete registry operations can be autoâ€‘repaired next run (e.g., a registry entry pointing at a nonâ€‘existent file triggers either recreation or removal, depending on the step).

6. **Testing the journal**

* Unit tests:

  * Fake operations in memory:

    * Simulate starting an entry, advancing `current_step`, then calling recovery and verifying expected behavior.
* Integration tests:

  * Introduce a **fault injection** flag (env var or feature) that forces a panic after step 1 of install.
  * Run `fontlift install <font>` with that flag set:

    * Process crashes midâ€‘install.
  * On next run (without fault):

    * Call `fontlift doctor` or have CLI autoâ€‘recovery run.
    * Assert font ends up either:

      * Fully installed and registered, or
      * Fully rolled back (no lingering file or registration).

---

## Smaller, but worthwhile, followâ€‘ons

If you want to keep things tight and avoid extra abstraction bloat (per your CLAUDE guidelines), Iâ€™d treat the two â€œbreakthroughsâ€ above as the real work and only optionally consider:

1. **Unifying the security model implementation with `SECURITY_CONSIDERATIONS.md`**

   You already documented things like `SecurityContext`, environment overrides, and protected paths. Some of this is implemented (e.g., `protection::is_protected_system_font_path`, admin checks on macOS), but others (e.g., `FontValidator`, `SecureFontRegistration`) are purely conceptual. 

   As you wire in the validator & journal, keep struct names and fields aligned with the doc so the threat model stays live and auditable.

2. **Python API hardening**

   The current Python stubs in `python/fontlift/__init__.py` and `cli.py` are syntactically invalid and clearly placeholders; when you flesh them out:

   * Make sure Python paths go through:

     * The new validator (Breakthrough 1).
     * The journaling operations (Breakthrough 2) via the Rust `FontManager`, not by reimplementing logic in Python.

---

If youâ€™d like, I can next sketch the exact code signatures and a migration plan for integrating the validator + journal while keeping the public CLI and Python APIs stable.
````

## LICENSE
```
                                 Apache License
                           Version 2.0, January 2004
                        http://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright [yyyy] [name of copyright owner]

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
```

## PLAN.md
```markdown
# FontLift Superset Convergence Plan (2025-12-01)

**One-sentence scope:** Deliver `fontlift` (Rust library + CLI + Python bindings) as a strict superset of `fontlift-mac-cli` and `fontlift-win-cli`, matching every behavior while adding a unified, testable, and convenient API surface.

## Current State (facts)
- Workspace crates exist (`core`, `platform-mac`, `platform-win`, `cli`, `python`), but macOS Core Text calls fail to compile; Windows path is unverified on non-Windows.
- CLI surface is minimal (list/install/uninstall/remove/cleanup) and lacks legacy flags (`--prune-only`, `--cache-only`, `--json`, batch ops, simulation/dry-run, aliases).
- Python bindings expose only path-based operations; no metadata, name-based operations, or cleanup/prune options; no packaging story for PyPI wheels.
- No automated parity checks against Swift/C++ CLIs; no fixture fonts; tests currently fail on macOS.

## Gap analysis vs legacy CLIs
- **macOS (Swift CLI)** missing: Core Text register/unregister, conflict detection/auto-resolve, rich metadata extraction, prune + third-party cache cleanup, system font protections with overrides, simulation/fake registry mode, environment overrides, complete flag set.
- **Windows (C++ CLI)** missing: real registry + GDI wiring for install/uninstall/list, conflict removal, cache cleanup (FontCache service + Adobe caches), admin detection paths, robust registry pruning, exit-code parity.
- **Cross-platform/CLI UX** missing: aliases (`i/u/rm/c/l`), `-p/-n/-s` toggles, JSON output, batch file/dir handling, quiet/verbose, dry-run, deterministic sorting, consistent error strings.
- **Python** missing: typed `FontliftFontSource/FontliftFontFaceInfo`, name-based operations, cleanup/prune toggles, JSON-friendly outputs, Fire-compatible CLI, maturin/pyproject for wheels, version sync with Cargo.
- **Verification** missing: golden-output tests, fixture fonts, CI matrix for macOS/Windows, migration docs from legacy CLIs.

## Workstreams (actionable)

### WS0 â€” Parity audit & build hygiene
- [x] Catalogue every command/flag/behavior in both legacy CLIs; update `FEATURE_MATRIX.md` with a parity checklist.
- [x] Fix macOS build blockers (Core Text constants, CFDictionary construction, feature gates) so `cargo test --workspace` passes locally.
- [x] Gate Windows-specific code to compile cleanly on macOS; add minimal mock stubs for non-target hosts to keep tests green.

### WS1 â€” macOS parity (Swift â†’ Rust)
- Implement Core Text register/unregister with scope options; copy fonts into user/system dirs with system font protection and conflict detection/auto-resolve. *(Done 2025-12-03: installs now copy into scope-specific dirs, auto-unregister/retry on CT conflicts, replace-on-reinstall in fake/user scopes, and `is_font_installed` inspects Core Text registrations/paths.)*
- Implement listing via `CTFontManagerCopyAvailableFontURLs` + descriptor metadata (PostScript/full/family/style/format) and scope tagging. *(Done 2025-12-02: descriptor-based listing with scope tagging and trait extraction.)*
- Implement cleanup: prune missing registrations, clear ATS caches, clear Adobe/Microsoft caches; flags `--prune-only`, `--cache-only`, `--admin`. *(Done 2025-12-02: pruning + cache clearing wired with flags and dry-run support.)*
- Add simulation/dry-run and fake registry mode for tests. *(Done 2025-12-03: `FONTLIFT_FAKE_REGISTRY_ROOT` plus CLI dry-run paths.)*

### WS2 â€” Windows parity (C++ â†’ Rust)
- Wire install/uninstall/remove to registry + GDI with file copy to per-user/system fonts, admin detection, conflict auto-removal.
- Implement listing from registry + fonts directory with metadata, deduplication, and scope detection.
- Implement cleanup: prune missing registry entries, clear FontCache service data, clear Adobe caches; support `--prune-only`, `--cache-only`, `--admin` and exit-code parity.
- *Progress 2025-12-03:* Registry pruning and FontCache stop/clear/start flow implemented; AdobeFnt*.lst purging added under Program Files; still pending validation on Windows hosts.
- *Progress 2025-12-03:* Install path now auto-detects conflicts (path/PostScript/family-style) and unregisters/removes duplicates before copy, while refusing to touch protected system font paths.
- *Progress 2025-12-03:* Listing now prefers name table metadata via `read-fonts` (PostScript/family/subfamily/full name) for registry + directory entries with scope tagging and deduplication.
- *Progress 2025-12-03:* Added cross-platform unit coverage for Adobe cache discovery/removal and ProgramFiles vs ProgramFiles(x86) deduplication to harden cleanup logic pending Windows host validation.
- *Progress 2025-12-03:* Registry values are stored as filenames when installed under Fonts roots and normalized back to absolute paths for listing/uninstall; cleanup now stops both FontCache and optional WPF font cache services before deleting cache files.
- *Progress 2025-12-03:* CLI cleanup now downgrades user-scope cache-clear `PermissionDenied` errors to warnings so default `fontlift cleanup` succeeds without `--admin` while keeping system-scope failures fatal.
- *Progress 2025-12-03:* Registry unregister/prune now normalize filename-only entries (case-insensitive) to prevent false positives and stale values when removing/pruning fonts.
- *Progress 2025-12-03:* Registry value matching helper now builds on non-Windows hosts so `cargo test -p fontlift-platform-win` stays green cross-platform while Windows validation remains pending.

### WS3 â€” Unified CLI ergonomics
- Align commands/flags with legacy binaries: aliases, batch install/remove, name- and path-based operations, JSON output, quiet/verbose, dry-run, deterministic sorting.
- Add migration-safe help text and consistent error/exit codes; add shell completion generation.
  - [x] Shell completion generation via `fontlift completions <shell>` writing to stdout.
  - [x] Exit code alignment with legacy binaries for common failure cases.
  - [x] Implemented `list --json` output with deterministic sorting and deduplication to stabilize scripting surface.
  - [x] Added batch file/dir handling plus `--dry-run`/`--quiet`/`--verbose` toggles for install/uninstall/remove commands.

### WS4 â€” Python bindings & packaging
- Expose full surface: typed `FontliftFontSource`/`FontliftFontFaceInfo`, list/install/uninstall/remove/cleanup with scope/admin/prune/cache/dry-run options, name-based ops, JSON-friendly return values.
- Add Fire-based CLI entry mirroring Rust CLI; keep behavior parity.
- Ship `pyproject.toml` + `maturin` workflow for universal2 macOS and win64/aarch64 wheels; sync versioning with Cargo.
- Progress 2025-12-03: PyO3 exports `FontSource` + `FontFaceInfo` classes (scope/format/face_index metadata), list/install/uninstall/remove now route through `FontliftFontSource`; cleanup/prune/cache toggles added to Python API; name-based uninstall/remove with dry-run support and Fire CLI cleanup toggles are wired; Fire CLI now mirrors Rust JSON list rendering and quiet/verbose/dry-run messaging; remaining gap is validating wheel packaging on macOS/Windows.

- Add font fixtures (TTF/OTF/TTC) and golden-output recordings from legacy binaries for list/install/uninstall/remove/cleanup.
- *Progress 2025-12-03:* Added Atkinson Hyperlegible TTF/OTF/TTC fixtures under `tests/fixtures/fonts`; golden outputs remain.
- Add Rust integration tests per platform using temp dirs and admin-check mocks; add Python `pytest` integration via `maturin develop`. *(Done 2025-12-03: macOS fake-registry integration coverage plus pytest harness with import skips when the extension isn't built.)*
- Stand up CI matrix (macOS + Windows) running `cargo test`, CLI smoke tests with fixtures, and Python wheel build/test; enforce coverage (>80% initial). *(Done 2025-12-03: Added GitHub Actions CI for macOS 14 + Windows runners with rustfmt/clippy, platform-scoped cargo test, maturin develop, and pytest against the Python bindings.)*

### WS6 â€” Documentation & release
- Update README/USAGE/FEATURE_MATRIX with parity status, flags, migration guide, and Python examples. *(Updated 2025-12-03: added packaging section documenting build.sh wheel output and Windows prerequisites.)*
- Harden build script (`build.sh`) and Windows packaging and document prerequisites.
- Publish release checklist, CHANGELOG entries, and distribution plan (crates.io, GitHub releases with binaries, PyPI wheels). *(Done 2025-12-03: added RELEASE_CHECKLIST.md for Rust crates + PyPI/GitHub steps.)*

### WS7 â€” Out-of-process font validation pipeline (Security/Robustness)
**Goal:** Move all "dangerous" font parsing into a separate, short-lived, resource-limited helper process using `read-fonts` for structural validation before the OS font stack ever sees the bytes.

- [x] Create `fontlift-validator` binary crate (`crates/fontlift-validator`) as a small helper process:
  - Accept list of paths + optional config (max size, timeout, allowed formats) via CLI flags or JSON stdin.
  - Use `read-fonts` to structurally parse fonts and extract metadata (PostScript name, family, style, weight, italic).
  - Enforce resource limits: max file size (default 64MB), timeout watchdog, extension + MIME sniffing.
  - Return JSON array of `{ ok: bool, info?: FontliftFontFaceInfo, error?: String }`.
  - Sanitize error strings (no internal paths/stack traces).
- [x] Add `validation_ext` module to `fontlift-core`:
  - `ValidatorConfig { max_file_size_bytes, timeout_ms, allow_collections }`.
  - `validate_and_introspect(paths, config) -> FontResult<Vec<Result<FontliftFontFaceInfo, FontError>>>`.
  - Spawn validator child process, send paths/config over stdin, parse JSON response.
- [x] Wire validator into macOS install path (`MacFontManager::install_font`):
  - Early call to `validate_single` before copy/registration when `validation_config` is set on manager.
  - Abort with `FontError::InvalidFormat` if validation fails.
  - Manager exposes `with_validation(config)` constructor and `set_validation_config()` setter.
- [x] Wire validator into Windows install path (`WinFontManager::install_font`) when fleshing out Windows parity.
- [x] Expose validation config in Python bindings:
  - Added `strict: bool = False` parameter on `install()` function and `FontliftManager.install_font()` method.
  - When `strict=True`, creates manager with `ValidatorConfig::default()` for out-of-process validation.
- [x] Expose validation in CLI:
  - `--no-validate` flag (default: validate on install).
  - `--validation-strictness {lenient,normal,paranoid}` presets.
  - Batch validation for installs (amortize process overhead).
- [x] Add unit tests:
  - Known-bad font samples (random binary with `.ttf` extension) â†’ clean error, no crash.
  - Max size / timeout behaviour with dummy files.
- [x] Add integration tests:
  - Malformed font fixture + `fontlift install` â†’ fails with `InvalidFormat`, no CT registration.
  - Tests in `crates/fontlift-cli/tests/macos_fake_registry_tests.rs` verify CLI and manager-level validation.

### WS8 â€” Transactional operation journal for crash-safe install/remove
**Goal:** Wrap multi-step operations (copy, register, unregister, delete, clear cache) in a small operation journal so interrupted operations can be auto-repaired on next run.

- [x] Add `journal` module to `fontlift-core`:
  - `JournalAction` enum: `CopyFile { from, to }`, `RegisterFont { path, scope }`, `UnregisterFont { path, scope }`, `DeleteFile { path }`, `ClearCache { scope }`.
  - `JournalEntry { id: Uuid, started_at, completed, actions: Vec<JournalAction>, current_step: usize }`.
  - Journal file location: macOS `~/Library/Application Support/FontLift/journal.json`, Windows `%LOCALAPPDATA%\FontLift\journal.json`.
  - Atomic write pattern (write to `.tmp` then rename).
- [x] Implement journal helpers:
  - `journal_path() -> PathBuf` (platform-specific).
  - `load_journal() -> Vec<JournalEntry>`, `save_journal(&[JournalEntry])`.
  - `record_operation(actions) -> JournalEntry`, `mark_step(entry_id, step)`, `mark_completed(entry_id)`.
- [x] Implement crash recovery logic:
  - `recover_incomplete_operations<F>(manager, handler)` iterates incomplete entries and rolls forward or back.
  - Policy per action: CopyFile (check exists/size), RegisterFont (check is_font_installed), UnregisterFont (retry if still installed), DeleteFile (delete if exists).
- [x] Wire journal into `MacFontManager::install_font`:
  - Build actions list: CopyFile (if needed), RegisterFont.
  - Call `record_operation`, execute actions with `mark_step` after each, then `mark_completed`.
- [x] Wire journal into `MacFontManager::remove_font` (UnregisterFont â†’ DeleteFile).
- [x] Wire journal into Windows manager when fully implemented.
- [x] Add CLI `fontlift doctor` command:
  - Runs `recover_incomplete_operations` and prints actions taken.
  - Optionally auto-run at process start (behind flag or env var).
- [x] Add unit tests:
  - Simulate starting entry, advancing steps, calling recovery â†’ verify expected rollback/forward.
- [x] Add integration tests:
  - `mac_fake_registry_doctor_recovers_incomplete_copy`: simulates crash after CopyFile record, verifies doctor recovery.
  - `mac_fake_registry_doctor_recovers_incomplete_delete`: simulates crash after DeleteFile record, verifies recovery.

## Milestones
- **M1:** Build passes on macOS and parity checklist completed (WS0).
- **M2:** macOS parity validated against Swift CLI fixtures (WS1).
- **M3:** Windows parity validated against C++ CLI fixtures (WS2).
- **M4:** Unified CLI + Python parity done (WS3â€“WS4).
- **M5:** CI matrix green with parity tests and docs/release updates (WS5â€“WS6).

## Verification approach (superset guarantee)
- Keep a living parity checklist derived from legacy help/output; every item mapped to Rust/Python behavior or explicitly deprecated with rationale.
- Golden-output tests compare Rust CLI/Python binding results to recorded legacy outputs for core commands on each platform.
- Contract tests ensure Python JSON structures match Rust CLI JSON output.
- Treat any missing feature or divergent behavior as a release blocker until resolved or documented.

## Architecture snapshot (for reference)
- Workspace crates: `fontlift-core` (errors, validation, traits), `fontlift-platform-mac`, `fontlift-platform-win`, `fontlift-cli`, `fontlift-python`.
- Platform APIs: macOS via Core Text/Objective-C; Windows via `windows` crate (GDI + Registry).
- Tooling: Rust 1.75+, PyO3 + maturin for bindings; clap for CLI; tests via `cargo test` + `pytest`.

*Last updated: 2025-12-03*
```

## README.md
````markdown
# FontLift

A cross-platform font management library and CLI tool written in Rust, consolidating the functionality of the existing Swift and C++ implementations into a unified codebase.

## Overview

FontLift provides:
- **Core Library**: Cross-platform font management abstraction
- **Platform Implementations**: Native macOS and Windows integration  
- **CLI Tool**: Command-line interface for font operations
- **Python Bindings**: PyO3 bindings for Python integration

## Status (2025-12-03)
- macOS: Parity with the Swift CLI including install/uninstall/remove, descriptor-based listing, cleanup with prune/cache toggles, and fake-registry/dry-run support.
- Windows: Registry + GDI install/uninstall/list and cache cleanup (FontCache + Adobe) are implemented; needs validation on a Windows host and golden-output capture.
- Python: Bindings expose `FontliftFontSource`/`FontliftFontFaceInfo`, name-based operations, cleanup toggles, and a Fire CLI; wheels build via `maturin`.
- CI: GitHub Actions matrix on macOS 14 and Windows runs `cargo fmt`, `cargo clippy`, platform-scoped tests, and `maturin develop` + `pytest` for Python bindings.

## Architecture

The project is organized into several crates:

- `fontlift-core`: Core traits, types, and platform-agnostic logic
- `fontlift-platform-mac`: macOS-specific implementation using Core Text
- `fontlift-platform-win`: Windows-specific implementation using Registry APIs
- `fontlift-cli`: Command-line interface built with Clap
- `fontlift-python`: Python bindings using PyO3

## Features

### Font Management
- âœ… Install fonts (user-level and system-level)
- âœ… Uninstall fonts (keeping files)
- âœ… Remove fonts (uninstall and delete)
- âœ… List installed fonts with metadata
- âœ… Clear font caches
- âœ… Cross-platform support (macOS, Windows)

### Font Formats Supported
- TrueType (.ttf, .ttc)
- OpenType (.otf, .otc)  
- Web Open Font Format (.woff, .woff2)
- macOS dfont (.dfont)

### Safety Features
- Validation of font files before installation
- Protection against modifying system fonts
- Proper error handling and reporting
- Scope-based operations (user vs system)

## Quick Start

### As a Rust Library

```rust
use fontlift_core::{FontManager, FontScope};
use fontlift_platform_mac::MacFontManager; // or WinFontManager

let manager = MacFontManager::new();
let font_path = std::path::PathBuf::from("my-font.ttf");

// Install font for current user
manager.install_font(&font_path, FontScope::User)?;

// List installed fonts
let fonts = manager.list_installed_fonts()?;
for font in fonts {
    println!("{}: {}", font.family_name, font.style);
}
```

### CLI Usage

```bash
# Install a font
fontlift install my-font.ttf

# List installed fonts (sorted; path-only output is deduped)
fontlift list

# List installed fonts as deterministic JSON
fontlift list --json

# Install multiple fonts or an entire directory (non-recursive)
fontlift install my-font.ttf extras/AnotherFont.otf fonts/

# Preview changes without touching the system
fontlift install my-font.ttf --dry-run --quiet

# Install system-wide (requires admin)
fontlift install my-font.ttf --admin

# List installed fonts with detailed fields (use --sorted to dedupe names/paths when combining)
fontlift list --path --name --sorted

# Uninstall a font
fontlift uninstall --name "MyFont"

# Remove a font (uninstall + delete)
fontlift remove my-font.ttf

# Clear font caches
fontlift cleanup

# Clear system caches (requires admin)
fontlift cleanup --admin

# Prune stale registrations without touching caches
fontlift cleanup --prune-only

# Clear caches only (skip pruning)
fontlift cleanup --cache-only

# Generate shell completions (bash|zsh|fish|powershell|elvish)
fontlift completions bash > /usr/local/etc/bash_completion.d/fontlift
```

### Python Integration

```python
import fontlift

# Create manager
manager = fontlift.FontliftManager()

# List fonts
fonts = manager.list_fonts()
for font in fonts:
    print(f"{font['family_name']}: {font['style']}")

# Install font
manager.install_font("my-font.ttf")

# Or use functional API
fontlift.install("my-font.ttf", admin=False)
fontlift.list()
fontlift.cleanup(prune=True, cache=True, admin=False, dry_run=True)

# Fire CLI mirror with JSON/quiet/verbose/dry-run toggles (parity with Rust CLI)
# fontliftpy list --json --path --name --sorted
# fontliftpy install my-font.ttf --dry_run True --quiet True
```

## Platform-Specific Details

### macOS
- Uses Core Text APIs for font registration
- Supports both user (`~/Library/Fonts`) and system (`/Library/Fonts`) scopes
- Cache clearing via `atsutil` commands
- Safe handling of system font protection

### Windows  
- Uses Windows Registry and GDI APIs
- Supports per-user and system-wide font installation
- Registry-based font tracking
- Safe handling of Windows Fonts directory protection

## Building

### Prerequisites
- Rust 1.75+
- Platform-specific build tools:
  - macOS: Xcode Command Line Tools
  - Windows: Visual Studio Build Tools

### Build Commands

```bash
# Build all workspace members
cargo build --workspace

# Build release
cargo build --workspace --release

# Run tests
cargo test --workspace

# Run with specific features
cargo build --workspace --features "python"
```

### Platform-Specific Builds

```bash
# Build only current platform
cargo build -p fontlift-core
cargo build -p fontlift-platform-mac  # macOS only
cargo build -p fontlift-platform-win  # Windows only

# Build CLI
cargo build -p fontlift-cli

# Build Python bindings
cargo build -p fontlift-python
```

### Packaging (CLI + Python wheels)

- Windows: run from the "x64 Native Tools" developer prompt with Visual Studio Build Tools installed; ensure Python 3.12+ is on PATH for PyO3.
- Cross-platform build helper: `./build.sh` will run fmt/clippy, build the workspace, and, when `maturin` is available, emit wheels via `crates/fontlift-python/Cargo.toml` into `dist-<mode>-<platform>-<arch>/`.
- Python wheels only: `maturin build -m crates/fontlift-python/Cargo.toml --release -o dist`.
- CLI release artifacts: `cargo build -p fontlift-cli --release` produces `target/release/fontlift`/`fontlift.exe` ready for packaging or signing.

## Testing

```bash
# Run all tests
cargo test --workspace

# Run specific crate tests
cargo test -p fontlift-core
cargo test -p fontlift-cli

# Run documentation tests
cargo test --doc

# Run with logging
RUST_LOG=debug cargo test --workspace
```

## Development

### Project Structure
```
fontlift/
â”œâ”€â”€ Cargo.toml              # Workspace configuration
â”œâ”€â”€ README.md
â”œâ”€â”€ crates/
â”‚   â”œâ”€â”€ fontlift-core/      # Core library
â”‚   â”œâ”€â”€ fontlift-platform-mac/  # macOS implementation
â”‚   â”œâ”€â”€ fontlift-platform-win/  # Windows implementation
â”‚   â”œâ”€â”€ fontlift-cli/       # Command-line interface
â”‚   â””â”€â”€ fontlift-python/    # Python bindings
â””â”€â”€ docs/
    â””â”€â”€ platform-specific.md
```

### Adding New Platforms
1. Create a new crate: `fontlift-platform-{platform}`
2. Implement the `FontManager` trait
3. Add platform-specific dependencies
4. Update workspace and CLI integration
5. Add tests and documentation

### Code Style
- Use `cargo fmt` for formatting
- Use `cargo clippy -- -D warnings` for linting
- Follow Rust API guidelines
- Document all public APIs

## Error Handling

FontLift uses a comprehensive error type system:

- `FontNotFound`: Font file doesn't exist
- `InvalidFormat`: Not a valid font file
- `RegistrationFailed`: Platform registration failed
- `SystemFontProtection`: Attempted to modify system font
- `PermissionDenied`: Insufficient privileges
- `AlreadyInstalled`: Font already exists
- `UnsupportedOperation`: Platform doesn't support operation

## Security Considerations

- Font files are validated before installation
- System fonts are protected from modification
- Scope-based privilege separation
- Safe path handling and sandboxing
- No network operations by default

## Performance

- Minimal memory allocations
- Efficient font metadata extraction
- Lazy loading of platform resources
- Async operations where applicable
- Optimized for bulk operations

## Roadmap

- [ ] Linux platform support (fontconfig integration)
- [ ] Font collection (.ttc/.otc) handling
- [ ] Variable font metadata extraction
- [ ] Font conflict detection and resolution
- [ ] Batch installation/uninstallation
- [ ] Font preview generation
- [ ] GUI application (via testypf integration)

## Contributing

1. Fork the repository
2. Create a feature branch
3. Add tests for new functionality
4. Ensure all tests pass
5. Submit a pull request

See [CONTRIBUTING.md](CONTRIBUTING.md) for detailed guidelines.

## License

FontLift is licensed under the Apache License 2.0. See [LICENSE](LICENSE) for details.

## Changelog

See [CHANGELOG.md](CHANGELOG.md) for version history and release notes.

---

Made by FontLab https://www.fontlab.com/
````

## RELEASE_CHECKLIST.md
```markdown
# FontLift Release Checklist (2025-12-03)

## Preconditions
- Working tree clean; all CI jobs green.
- Versions bumped in `Cargo.toml` and `pyproject.toml`; changelog updated.
- Confirm `README.md`, `USAGE.md`, and `FEATURE_MATRIX.md` match the release surface.

## Rust crates (workspace)
- Run `cargo fmt`, `cargo clippy -- -D warnings`, and `cargo test --workspace --exclude fontlift-python`.
- For each publishable crate, run `cargo publish --dry-run` to catch packaging issues before uploading. îˆ€citeîˆ‚turn0search0îˆ
- If using CI-based publishing, ensure crates.io Trusted Publishing is configured after an initial manual publish so GitHub Actions can mint short-lived tokens via OIDC. îˆ€citeîˆ‚turn0search1îˆ‚turn0search4îˆ
- Optional: rehearse tagging/version bumps with `cargo release --dry-run`; switch to `--execute` when ready. îˆ€citeîˆ‚turn0search6îˆ
- Publish crates in dependency order (core â†’ platform crates â†’ CLI â†’ Python helper crates if any).

## Python wheels
- Ensure the Python extension builds locally: `maturin develop -m crates/fontlift-python/Cargo.toml --features python-bindings`.
- Build and upload release wheels with `maturin publish -m crates/fontlift-python/Cargo.toml --features python-bindings` (uses the same command to build and push to PyPI).
- If using CI, prefer trusted secretless publishing; otherwise supply a short-lived PyPI token.

## GitHub release
- Tag the commit (`vX.Y.Z`) after publishes succeed; push tags.
- Draft a GitHub release that links the changelog section, attaches prebuilt binaries/wheels if produced, and notes platform caveats (Windows validation pending).

## Post-release
- Yank or deprecate superseded versions if needed.
- Update `CHANGELOG.md`, `PLAN.md`, `TODO.md`, and `WORK.md` with release status.
- Announce internally; capture any follow-up bugs in `TODO.md`.
```

## SECURITY_CONSIDERATIONS.md
````markdown
# FontLift Security Considerations

This document outlines the security considerations, threat model, and protective measures implemented in FontLift to ensure safe font management operations across platforms.

## 1. Threat Model

### 1.1. Asset Classification
**Critical Assets**:
- System font directories (`/System/Library/Fonts`, `/Library/Fonts`, `C:\Windows\Fonts`)
- Font registration databases (Core Text, Windows Registry)
- User font directories (`~/Library/Fonts`, user profile fonts)
- Font cache files and system services

**Threat Actors**:
1. **Malicious Software**: Attempting to install malicious fonts
2. **Privilege Escalation**: Trying to gain system access through font operations
3. **Denial of Service**: Corrupting font system to break applications
4. **Information Disclosure**: Accessing font metadata or user data

### 1.2. Attack Vectors
1. **Font File Attacks**: Malicious font files (exploitable fonts, corrupted data)
2. **Path Traversal**: Directory traversal in font installation
3. **Privilege Escalation**: Requesting admin rights inappropriately
4. **Cache Poisoning**: Corrupting font cache mechanisms
5. **Race Conditions**: Exploiting installation timing

## 2. Security Architecture

### 2.1. Defense in Depth Strategy
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    User Interface                         â”‚
â”‚  â€¢ Clear admin requirement indicators                    â”‚
â”‚  â€¢ Confirmation dialogs for dangerous operations         â”‚
â”‚  â€¢ Dry-run mode for testing                              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                 Business Logic Layer                      â”‚
â”‚  â€¢ System font protection                                â”‚
â”‚  â€¢ Operation validation                                   â”‚
â”‚  â€¢ Scope enforcement                                      â”‚
â”‚  â€¢ Audit logging                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                Platform Implementation                    â”‚
â”‚  â€¢ Platform-specific security checks                     â”‚
â”‚  â€¢ Safe API usage                                        â”‚
â”‚  â€¢ Error handling                                        â”‚
â”‚  â€¢ Resource cleanup                                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## 3. Protective Measures

### 3.1. System Font Protection

**Protected Directories**:
```rust
// macOS protected paths
const SYSTEM_FONT_PATHS: &[&str] = &[
    "/System/Library/Fonts",
    "/System/Library/Assets/com_apple_MobileAsset_Font3",
    "/Library/Application Support/Apple/Fonts",
];

// Windows protected paths  
const SYSTEM_FONT_PATHS: &[&str] = &[
    "C:\\Windows\\Fonts",
    "C:\\Windows\\System32\\fonts",
];
```

**Protection Mechanisms**:
- âœ… **Path Validation**: Block operations on system font directories
- âœ… **Runtime Checks**: Verify paths before any operation
- âœ… **User Warnings**: Clear messages about system font protection
- âœ… **Configuration**: Allow override for testing with explicit flags

### 3.2. Privilege Management

**Principle of Least Privilege**:
```rust
pub struct SecurityContext {
    current_user: String,
    is_admin: bool,
    allowed_scopes: Vec<FontScope>,
    requires_confirmation: bool,
}

impl SecurityContext {
    pub fn can_perform_operation(&self, operation: &FontOperation) -> bool {
        match operation.scope {
            FontScope::User => true, // Always allowed
            FontScope::System => self.is_admin && self.allowed_scopes.contains(&FontScope::System),
        }
    }
}
```

**Admin Detection**:
```rust
// Cross-platform admin detection
#[cfg(target_os = "macos")]
pub fn is_admin() -> bool {
    unsafe { libc::geteuid() == 0 }
}

#[cfg(target_os = "windows")]
pub fn is_admin() -> bool {
    // Windows-specific admin check using winapi
    // TODO: Implement proper Windows admin detection
    windows_admin_check()
}
```

### 3.3. File Validation and Sandboxing

**Font File Validation**:
```rust
pub struct FontValidator {
    max_file_size: usize,
    allowed_extensions: Vec<String>,
    scan_for_malware: bool,
}

impl FontValidator {
    pub fn validate_font_file(&self, path: &PathBuf) -> FontResult<()> {
        // 1. Basic file checks
        self.validate_basic_properties(path)?;
        
        // 2. Extension validation
        self.validate_extension(path)?;
        
        // 3. Size limits
        self.validate_file_size(path)?;
        
        // 4. Content validation
        self.validate_font_content(path)?;
        
        // 5. Malware scanning (optional)
        if self.scan_for_malware {
            self.scan_for_threats(path)?;
        }
        
        Ok(())
    }
}
```

**Sandboxing Strategy**:
- âœ… **Temporary Isolation**: Work in temp directories before installation
- âœ… **Content Validation**: Validate font content before registration
- âœ… **Resource Limits**: Limit memory and CPU usage during operations
- âœ… **Timeout Protection**: Prevent infinite operations

### 3.4. Secure Font Registration

**Safe Registration Process**:
```rust
impl SecureFontRegistration {
    pub fn install_font_safely(&self, source_path: &PathBuf, scope: FontScope) -> FontResult<()> {
        // 1. Security validation
        self.security_context.validate_operation(&source_path, scope)?;
        
        // 2. File validation
        self.validator.validate_font_file(source_path)?;
        
        // 3. Create backup plan
        let backup = self.create_backup_plan(source_path)?;
        
        // 4. Perform installation in temp location first
        let temp_path = self.prepare_temp_installation(source_path)?;
        
        // 5. Validate installed font
        self.validate_installed_font(&temp_path)?;
        
        // 6. Move to final location
        self.commit_installation(&temp_path, scope)?;
        
        // 7. Update registry/database safely
        self.update_font_registration(&temp_path, scope)?;
        
        Ok(())
    }
}
```

### 3.5. Cache Security

**Secure Cache Operations**:
```rust
pub struct SecureCacheManager {
    cache_directory: PathBuf,
    allowed_operations: CacheOperations,
}

impl SecureCacheManager {
    pub fn clear_caches_safely(&self, scope: FontScope) -> FontResult<CacheClearResult> {
        // 1. Validate permissions
        self.validate_cache_permissions(scope)?;
        
        // 2. Create backup of critical cache data
        let backup = self.backup_cache_data(scope)?;
        
        // 3. Clear non-critical caches first
        let result = self.clear_user_caches()?;
        
        // 4. Clear system caches with elevated privileges
        if scope == FontScope::System {
            let system_result = self.clear_system_caches_with_elevation()?;
            result.merge(system_result);
        }
        
        // 5. Verify system stability
        self.verify_system_stability()?;
        
        Ok(result)
    }
}
```

## 4. Configuration Security

### 4.1. Secure Configuration Management
```rust
impl FontliftConfig {
    pub fn load_secure_config() -> Result<Self> {
        let mut config = Self::from_env()?;
        
        // Apply security overrides
        if !is_admin() {
            config.permissions.allow_system_operations = false;
        }
        
        // Validate dangerous settings
        if config.font_paths.system_library_override.is_some() {
            log::warn!("System library override detected - ensure this is intentional");
        }
        
        // Enforce reasonable limits
        config.permissions.max_batch_size = config.permissions.max_batch_size.min(10000);
        config.performance.max_cache_size_mb = config.performance.max_cache_size_mb.min(1000);
        
        Ok(config)
    }
}
```

### 4.2. Environment Variable Security
```rust
// Security-sensitive environment variables
const SECURE_VARS: &[(&str, &str)] = &[
    ("FONTLIFT_ALLOW_SYSTEM", "Allow system-level operations"),
    ("FONTLIFT_DRY_RUN", "Enable dry-run mode for testing"),
    ("FONTLIFT_OVERRIDE_USER_LIBRARY", "Override user font directory"),
    ("FONTLIFT_OVERRIDE_SYSTEM_LIBRARY", "Override system font directory"),
];

pub fn validate_environment() -> FontResult<()> {
    for (var, description) in SECURE_VARS {
        if std::env::var(var).is_ok() {
            log::info!("Security override active: {} - {}", var, description);
        }
    }
    
    // Check for suspicious combinations
    if std::env::var("FONTLIFT_ALLOW_SYSTEM").is_ok() && !is_admin() {
        log::warn!("System operations requested but not running as admin");
    }
    
    Ok(())
}
```

## 5. Error Handling and Auditing

### 5.1. Secure Error Handling
```rust
impl FontError {
    pub fn sanitize_for_user_display(&self) -> String {
        match self {
            FontError::SystemFontProtection(path) => {
                format!("Cannot modify system font at {}. System fonts are protected for stability.", path.display())
            },
            FontError::PermissionDenied(operation) => {
                format!("Permission denied for '{}'. This operation may require administrator privileges.", operation)
            },
            FontError::FontNotFound(path) => {
                // Don't expose full paths in user messages
                format!("Font file not found. Please check the file path and try again.")
            },
            _ => {
                // Generic error message for internal errors
                "An error occurred while processing the font operation. Please check the logs for details.".to_string()
            }
        }
    }
}
```

### 5.2. Audit Logging
```rust
pub struct SecurityAuditor {
    log_file: Option<PathBuf>,
    log_level: LogLevel,
}

impl SecurityAuditor {
    pub fn log_font_operation(&self, operation: &FontOperation, result: &FontResult<()>) {
        let audit_entry = AuditEntry {
            timestamp: SystemTime::now(),
            user: current_user(),
            operation: operation.clone(),
            success: result.is_ok(),
            error: result.as_ref().err().map(|e| e.to_string()),
        };
        
        // Log to security log
        log::info!("Font operation audit: {:?}", audit_entry);
        
        // Write to audit file if configured
        if let Some(ref log_file) = self.log_file {
            let _ = self.write_audit_log(log_file, &audit_entry);
        }
    }
}
```

## 6. Platform-Specific Security

### 6.1. macOS Security Considerations
```rust
// macOS-specific security measures
#[cfg(target_os = "macos")]
pub mod macos_security {
    use super::*;
    
    // Core Text security validation
    pub fn validate_core_text_operation(path: &PathBuf, scope: FontScope) -> FontResult<()> {
        // Check System Integrity Protection (SIP) status
        if is_sip_protected_path(path) && scope == FontScope::System {
            return Err(FontError::SystemFontProtection(path.clone()));
        }
        
        // Validate against macOS font database
        validate_against_font_database(path)?;
        
        Ok(())
    }
    
    // Check for System Integrity Protection
    fn is_sip_protected_path(path: &PathBuf) -> bool {
        path.starts_with("/System/Library/") ||
        path.starts_with("/usr/libexec/")
    }
}
```

### 6.2. Windows Security Considerations
```rust
// Windows-specific security measures
#[cfg(target_os = "windows")]
pub mod windows_security {
    use super::*;
    
    // Windows font registry security
    pub fn validate_registry_operation(path: &PathBuf, scope: FontScope) -> FontResult<()> {
        // Check Windows Resource Protection
        if is_wrp_protected_path(path) {
            return Err(FontError::SystemFontProtection(path.clone()));
        }
        
        // Validate against Windows font registry
        validate_against_font_registry(path)?;
        
        Ok(())
    }
    
    // Check for Windows Resource Protection
    fn is_wrp_protected_path(path: &PathBuf) -> bool {
        // TODO: Implement WRP path checking
        path.starts_with("C:\\Windows\\System32\\") ||
        path.starts_with("C:\\Windows\\SysWOW64\\")
    }
}
```

## 7. Testing and Validation

### 7.1. Security Testing Strategy
```rust
#[cfg(test)]
mod security_tests {
    use super::*;
    
    #[test]
    fn test_system_font_protection() {
        let system_font = PathBuf::from("/System/Library/Fonts/Arial.ttf");
        let validator = FontValidator::default();
        
        assert!(validator.validate_font_file(&system_font).is_err());
    }
    
    #[test]
    fn test_privilege_enforcement() {
        let context = SecurityContext::for_current_user();
        
        // Normal user shouldn't be able to perform system operations
        if !context.is_admin {
            assert!(!context.can_perform_operation(&FontOperation {
                path: PathBuf::from("test.ttf"),
                scope: FontScope::System,
            }));
        }
    }
    
    #[test]
    fn test_safe_installation_process() {
        // Test that installation fails gracefully with malicious files
        let malicious_font = create_test_malicious_font();
        let installer = SecureFontRegistration::new();
        
        assert!(installer.install_font_safely(&malicious_font, FontScope::User).is_err());
    }
}
```

## 8. Security Best Practices

### 8.1. User-Facing Security
1. **Clear Warnings**: Always warn before system operations
2. **Confirmation Dialogs**: Require confirmation for dangerous operations
3. **Dry Run Mode**: Allow testing without making changes
4. **Backup Suggestions**: Suggest backups before major operations
5. **Progress Feedback**: Show what's happening during operations

### 8.2. Developer Security
1. **Input Validation**: Validate all user inputs and file paths
2. **Error Handling**: Never expose internal details in user messages
3. **Resource Management**: Proper cleanup of temporary files and resources
4. **Logging**: Comprehensive audit logging for security events
5. **Testing**: Regular security testing and validation

### 8.3. Operational Security
1. **Least Privilege**: Only request necessary permissions
2. **Code Signing**: Sign binaries for distribution
3. **Dependency Management**: Regular security updates for dependencies
4. **Monitoring**: Monitor for unusual patterns or attacks
5. **Incident Response**: Have a plan for security incidents

---

**Security Status**: Comprehensive security model implemented with defense in depth strategy
**Next Steps**: Complete platform-specific security implementations and add integration tests
**Review Schedule**: Quarterly security reviews and after major feature updates

*Last Updated: 2025-11-21*
````

## TODO.md
```markdown
# fontlift TODO (2025-12-01)

- [x] Audit legacy `fontlift-mac-cli` and `fontlift-win-cli` commands/flags/behaviors and update `FEATURE_MATRIX.md` with a parity checklist.
- [x] Fix macOS build blockers (Core Text constants, CFDictionary construction) so `cargo test --workspace` passes on macOS; gate Windows code for non-Windows hosts.
- [x] Implement macOS install/uninstall/remove using Core Text register/unregister with scope options, safe copy to user/system dirs, conflict detection/auto-resolve, and system font protection.
- [x] Implement macOS listing via `CTFontManagerCopyAvailableFontURLs` with descriptor-based metadata and scope tagging.
- [x] Implement macOS cleanup (prune missing registrations + ATS/Adobe/Microsoft cache clearing) with `--prune-only`, `--cache-only`, `--admin` flags.
- [x] Add macOS simulation/dry-run + fake registry mode to mirror Swift testing features (`FONTLIFT_FAKE_REGISTRY_ROOT`, CLI `--dry-run`).
- [~] Implement Windows install/uninstall/remove using registry + GDI, file copy to per-user/system fonts, admin detection, and conflict auto-removal.
  - Conflict detection now auto-uninstalls conflicting registry/file entries before copying while protecting system font paths.
  - Registry values are now normalized to the installed scope (filenames for Fonts roots; relative registry entries resolve to absolute paths), and uninstall/remove can resolve renamed entries via registry lookups.
  - Registry cleanup now matches filename-only entries case-insensitively when unregistering and pruning, preventing orphaned entries from surviving installs/removes.
  - Registry value matcher now builds on non-Windows hosts, keeping `cargo test -p fontlift-platform-win` green cross-platform.
- [x] Implement Windows listing from registry + fonts directory with metadata extraction, deduplication, and scope detection.
- [~] Implement Windows cleanup (registry prune, FontCache service reset, Adobe cache clearing) with `--prune-only`, `--cache-only`, `--admin` and exit-code parity.
  - Registry pruning and FontCache service stop/clear/start paths implemented; AdobeFnt*.lst purge added under Program Files; needs validation on a Windows host.
  - Added cross-platform unit coverage for Adobe cache discovery/removal and ProgramFiles/ProgramFiles(x86) deduplication to reduce cleanup regressions.
  - Cache clearing now stops/starts both `FontCache` and `FontCache3.0.0.0` (best-effort when the WPF cache service is absent).
  - CLI cleanup now treats user-scope cache clear `PermissionDenied` errors as warnings to keep default `fontlift cleanup` usable without `--admin`; system-scope still fails without elevation.
- [x] Add cross-platform conflict detection in `fontlift-core`; duplicate handling and system-font protection helpers added.
  - Conflict detection helper added and wired into Windows installs to auto-remove duplicate registrations/files before copying.
- [x] Expand CLI to match legacy ergonomics: aliases, batch file/dir installs, name- and path-based uninstall/remove, `-p/-n/-s`, `--json`, `--dry-run`, `--quiet/--verbose`, deterministic sorting, and help text updates.
- [x] Add CLI `list` JSON output with deterministic sorting and deduplication for repeat entries.
- [x] Add shell completion generation via `fontlift completions <shell>` and align exit codes with legacy binaries.
- [x] Expand Python bindings: typed `FontliftFontSource`/`FontliftFontFaceInfo` exposed to Python with `.dict()` for JSON; cleanup/prune/cache toggles added; name-based operations and Fire CLI parity completed.
- Fire CLI now mirrors Rust `list` JSON/flags, quiet/verbose/dry-run messaging, and default deduped path output; functional `list_fonts` now returns dictionaries matching documented examples.
- [x] Add `pyproject.toml` + packaging workflow for platform wheels; sync Python versioning with git tags via hatch-vcs.
- [x] Create font fixtures (TTF/OTF/TTC) and golden-output recordings from legacy binaries for list/install/uninstall/remove/cleanup.
  - Added Atkinson Hyperlegible TTF/OTF/TTC fixtures under `tests/fixtures/fonts`.
  - Created `tests/fixtures/golden_outputs/list_json_schema.json` documenting expected JSON structure.
  - Integration tests validate deterministic JSON output and schema compliance.
- [x] Add Rust integration tests per platform with temp dirs and admin-check mocks; add Python `pytest` integration via `maturin develop`.
- [x] Stand up CI matrix (macOS + Windows) running `cargo test`, CLI smoke tests with fixtures, and Python wheel build/test with coverage gates.
- [x] Update README/USAGE/FEATURE_MATRIX with parity status, migration guide, and Python examples; refresh build script (`build.sh`) and Windows packaging docs.
  - Status docs refreshed with macOS/Windows/Python parity summary and cleanup toggles; FEATURE_MATRIX updated 2025-12-03; packaging section added covering build.sh/wheel outputs and Windows prerequisites.
- [x] Publish release checklist, CHANGELOG entries, and keep WORK log updated alongside TODO status.

## WS7 â€” Out-of-process font validation pipeline

- [x] Create `fontlift-validator` binary crate with `read-fonts` parsing, max-size/timeout enforcement, and JSON output.
- [x] Add `validation_ext` module to `fontlift-core` with `ValidatorConfig` and `validate_and_introspect` API.
- [x] Wire validator into macOS `MacFontManager::install_font` for pre-flight validation. *(Manager now validates when `validation_config` is set; CLI also pre-validates.)*
- [x] Wire validator into Windows `WinFontManager::install_font` when Windows parity is complete.
- [x] Expose `strict`/`validation_config` in Python bindings (`install`, `cleanup`). *(Added `strict=False` parameter to `install()` and `FontliftManager.install_font()`.)*
- [x] Add CLI `--no-validate` and `--validation-strictness {lenient,normal,paranoid}` flags.
- [x] Add unit tests for malformed fonts, max-size, and timeout behaviour.
- [x] Add integration tests: malformed font fixture â†’ `InvalidFormat` error, no OS registration.
  - Tests in `crates/fontlift-cli/tests/macos_fake_registry_tests.rs` verify CLI and manager-level validation.

## WS8 â€” Transactional operation journal

- [x] Add `journal` module to `fontlift-core` with `JournalAction`, `JournalEntry`, and atomic file writes.
- [x] Implement journal helpers: `journal_path`, `load_journal`, `save_journal`, `record_operation`, `mark_step`, `mark_completed`.
- [x] Implement `recover_incomplete_operations` with roll-forward/rollback policy per action type.
- [x] Wire journal into `MacFontManager::install_font` (CopyFile, RegisterFont actions).
- [x] Wire journal into `MacFontManager::remove_font` (UnregisterFont, DeleteFile actions).
- [x] Wire journal into Windows manager when fully implemented.
- [x] Add CLI `fontlift doctor` command for manual recovery.
- [x] Add unit tests for journal entry lifecycle and recovery logic.
- [x] Add integration tests with fault injection (panic mid-install) and recovery verification.
  - `mac_fake_registry_doctor_recovers_incomplete_copy`: simulates crash after CopyFile journal record, verifies doctor recovery.
  - `mac_fake_registry_doctor_recovers_incomplete_delete`: simulates crash after DeleteFile journal record, verifies doctor recovery.
```

## USAGE.md
````markdown
# FontLift Usage Guide

This guide provides comprehensive usage examples for FontLift, both as a library and as a CLI tool.

## CLI Usage

### Basic Commands

```bash
# List installed fonts (sorted; path-only output is deduped)
fontlift list

# List as JSON (deterministic order, includes path + names)
fontlift list --json

# List with detailed information (use --sorted to dedupe names/paths when combining)
fontlift list --path --name --sorted

# Install one or more fonts for current user
fontlift install /path/to/font.ttf /other/font.otf

# Install every font in a directory (non-recursive)
fontlift install /path/to/font-folder

# Install system-wide (requires admin)
fontlift install /path/to/font.ttf --admin

# Preview what would happen without changing the system
fontlift install /path/to/font.ttf --dry-run

# Quieter or more verbose status output
fontlift install /path/to/font.ttf --quiet
fontlift install /path/to/font.ttf --verbose

# Uninstall a font by name
fontlift uninstall --name "Arial"

# Uninstall by file path or directory
fontlift uninstall /path/to/font.ttf /path/to/font-folder

# Remove font (uninstall + delete)
fontlift remove /path/to/font.ttf /path/to/font-folder

# Clear font caches
fontlift cleanup

# Clear system caches (requires admin)
fontlift cleanup --admin

# Prune stale registrations without clearing caches
fontlift cleanup --prune-only

# Clear caches only (skip pruning)
fontlift cleanup --cache-only

# Generate shell completions (bash|zsh|fish|powershell|elvish)
fontlift completions bash > /usr/local/etc/bash_completion.d/fontlift

# Recover from interrupted operations (crash recovery)
fontlift doctor

# Preview what would be recovered without taking action
fontlift doctor --preview
```

### Font Validation

```bash
# Install with out-of-process validation (default)
fontlift install /path/to/font.ttf

# Skip validation (faster, less safe)
fontlift install /path/to/font.ttf --no-validate

# Use stricter validation
fontlift install /path/to/font.ttf --validation-strictness paranoid
```

## Library Usage

### Basic Font Management

```rust
use fontlift_core::{FontManager, FontScope};
use fontlift_platform_mac::MacFontManager; // or WinFontManager

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let manager = MacFontManager::new();
    
    // Install font
    let font_path = std::path::PathBuf::from("my-font.ttf");
    manager.install_font(&font_path, FontScope::User)?;
    
    // List fonts
    let fonts = manager.list_installed_fonts()?;
    for font in fonts {
        println!("{}: {}", font.family_name, font.style);
    }
    
    Ok(())
}
```

### Font Validation

```rust
use fontlift_core::validation;

fn validate_font(path: &std::path::Path) -> Result<(), fontlift_core::FontError> {
    // Check file extension
    if !validation::is_valid_font_extension(&path.to_path_buf()) {
        return Err(fontlift_core::FontError::InvalidFormat(
            "Invalid font extension".to_string()
        ));
    }
    
    // Validate file contents
    validation::validate_font_file(&path.to_path_buf())?;
    
    // Extract basic information
    let info = validation::extract_basic_info_from_path(&path.to_path_buf());
    println!("Font: {} - {}", info.family_name, info.style);
    
    Ok(())
}
```

### Cross-Platform Manager Creation

```rust
use fontlift_core::FontManager;
use std::sync::Arc;

fn create_font_manager() -> Arc<dyn FontManager> {
    #[cfg(target_os = "macos")]
    {
        Arc::new(fontlift_platform_mac::MacFontManager::new())
    }
    
    #[cfg(target_os = "windows")]
    {
        Arc::new(fontlift_platform_win::WinFontManager::new())
    }
    
    #[cfg(not(any(target_os = "macos", target_os = "windows")))]
    {
        Arc::new(fontlift_core::DummyFontManager)
    }
}
```

## Python Integration

### Basic Python Usage

```python
import fontlift

# Create manager
manager = fontlift.FontliftManager()

# List fonts
fonts = manager.list_fonts()
for font in fonts:
    print(f"{font['family_name']}: {font['style']}")

# Install font
manager.install_font("my-font.ttf")

# Functional API
fontlift.install("my-font.ttf", admin=False)
fontlift.list()
fontlift.cleanup(admin=False)

# Cleanup with toggles and dry-run support
fontlift.cleanup(prune=True, cache=True, admin=False, dry_run=True)

# Fire CLI mirror with JSON/quiet/verbose/dry-run toggles (matches Rust CLI)
# fontliftpy list --json --path --name --sorted
# fontliftpy install my-font.ttf --dry_run True --quiet True
```

Notes:
- Windows install/remove/cleanup honor `admin` to pick system scope; calls that require elevation will raise `PermissionDenied`.
- macOS supports fake-registry/dry-run paths for tests via `FONTLIFT_FAKE_REGISTRY_ROOT`.

## Error Handling

FontLift provides comprehensive error types:

```rust
use fontlift_core::FontError;

match manager.install_font(&font_path, FontScope::User) {
    Ok(()) => println!("Font installed successfully"),
    Err(FontError::FontNotFound(path)) => {
        println!("Font file not found: {}", path.display());
    },
    Err(FontError::InvalidFormat(msg)) => {
        println!("Invalid font format: {}", msg);
    },
    Err(FontError::PermissionDenied(msg)) => {
        println!("Permission denied: {}", msg);
    },
    Err(e) => println!("Other error: {}", e),
}
```

## Font Formats Supported

- TrueType (.ttf, .ttc)
- OpenType (.otf, .otc)  
- Web Open Font Format (.woff, .woff2)
- macOS dfont (.dfont)

## Security Considerations

- Font files are validated before installation
- System fonts are protected from modification
- Scope-based privilege separation (user vs system)
- Safe path handling and sandboxing

## Performance Tips

- Use batch operations when installing multiple fonts
- Cache font information when listing frequently
- Use appropriate scope (User vs System) for your use case
- Consider font validation costs in performance-critical applications

## Platform-Specific Notes

### macOS

- Uses Core Text APIs for font registration
- Supports user (`~/Library/Fonts`) and system (`/Library/Fonts`) scopes
- Cache clearing via `atsutil` commands

### Windows

- Uses Windows Registry and GDI APIs
- Supports per-user and system-wide font installation
- Registry-based font tracking

### Linux (Not Yet Supported)

- Planned support via fontconfig integration
- Will support standard font directories
````

## build.sh
```bash
#!/bin/bash

# FontLift Build Script - Production Ready
# Optimized cross-platform build script for fontlift library and CLI
# Ensures 100% reliability on fresh systems with automated dependency checking

set -euo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
PURPLE='\033[0;35m'
CYAN='\033[0;36m'
NC='\033[0m' # No Color

# Script configuration
SCRIPT_NAME="FontLift Production Builder"
VERSION="2.0.0-dev"
MIN_RUST_VERSION="1.75.0"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

# Function to print colored output
print_header() {
	echo -e "${PURPLE}=== $SCRIPT_NAME v${VERSION} ===${NC}"
	echo -e "${PURPLE}========================================${NC}"
}

print_status() {
	echo -e "${GREEN}[âœ“ INFO]${NC} $1"
}

print_warning() {
	echo -e "${YELLOW}[âš  WARN]${NC} $1"
}

print_error() {
	echo -e "${RED}[âœ— ERROR]${NC} $1"
}

print_step() {
	echo -e "${BLUE}[â†’ STEP]${NC} $1"
}

print_success() {
	echo -e "${GREEN}[âœ“ SUCCESS]${NC} $1"
}

print_substep() {
	echo -e "${CYAN}  â€¢${NC} $1"
}

# Function to check if command exists
command_exists() {
	command -v "$1" >/dev/null 2>&1
}

# Function to compare versions
version_compare() {
	local version1="$1" operator="$2" version2="$3"
	if [[ "$operator" == ">=" ]]; then
		[[ "$(printf '%s\n' "$version1" "$version2" | sort -V | head -n1)" == "$version2" ]]
	elif [[ "$operator" == ">" ]]; then
		[[ "$version1" != "$version2" && "$(printf '%s\n' "$version1" "$version2" | sort -V | head -n1)" == "$version2" ]]
	fi
}

# Function to get platform information
get_platform_info() {
	local platform="unknown"
	local arch="unknown"
	local dylib_suffix=".so"
	
	# Detect platform
	if [[ "$OSTYPE" == "darwin"* ]]; then
		platform="macos"
		dylib_suffix=".dylib"
	elif [[ "$OSTYPE" == "linux-gnu"* ]]; then
		platform="linux"
		dylib_suffix=".so"
	elif [[ "$OSTYPE" == "msys" ]] || [[ "$OSTYPE" == "cygwin" ]]; then
		platform="windows"
		dylib_suffix=".dll"
	fi
	
	# Detect architecture
	case $(uname -m) in
		x86_64) arch="x86_64" ;;
		arm64) arch="arm64" ;;
		aarch64) arch="aarch64" ;;
		*) arch="unknown" ;;
	esac
	
	echo "$platform:$arch:$dylib_suffix"
}

# Function to check and install dependencies
check_and_install_dependencies() {
	local platform_info=$(get_platform_info)
	local platform=$(echo "$platform_info" | cut -d: -f1)
	
	print_step "Checking and installing dependencies..."
	
	# Check if we're in the right directory
	if [ ! -f "$SCRIPT_DIR/Cargo.toml" ]; then
		print_error "Cargo.toml not found. Please run this script from the fontlift root directory."
		exit 1
	fi
	
	# Check for Rust
	if ! command_exists cargo; then
		print_error "Rust/Cargo not found. Installing Rust..."
		print_status "Downloading rustup installer..."
		curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
		source "$HOME/.cargo/env"
		
		if ! command_exists cargo; then
			print_error "Failed to install Rust. Please install manually from https://rustup.rs/"
			exit 1
		fi
	else
		print_status "Rust/Cargo found âœ“"
	fi
	
	# Check Rust version
	local rust_version
	rust_version=$(rustc --version | cut -d' ' -f2)
	if ! version_compare "$rust_version" ">=" "$MIN_RUST_VERSION"; then
		print_error "Rust version $rust_version is too old. Minimum required: $MIN_RUST_VERSION"
		print_status "Updating Rust..."
		rustup update
		rust_version=$(rustc --version | cut -d' ' -f2)
		if ! version_compare "$rust_version" ">=" "$MIN_RUST_VERSION"; then
			print_error "Failed to update Rust to required version"
			exit 1
		fi
	fi
	print_status "Rust version: $rust_version âœ“"
	
	# Platform-specific dependency checks
	case $platform in
	macos)
		check_macos_dependencies
		;;
	windows)
		check_windows_dependencies
		;;
	linux)
		check_linux_dependencies
		;;
	esac
	
	# Check for optional but recommended tools
	check_optional_dependencies
}

# Function to check macOS dependencies
check_macos_dependencies() {
	print_substep "Checking macOS dependencies..."
	
	# Check for Xcode command line tools
	if ! command_exists xcodebuild; then
		print_warning "Xcode command line tools not found. Installing..."
		xcode-select --install
		print_status "Waiting for Xcode command line tools installation..."
		print_status "Please run the script again after installation completes."
		exit 0
	else
		print_status "Xcode command line tools found âœ“"
	fi
	
	# Check for Python (for Python bindings)
	if command_exists python3; then
		print_status "Python 3 found âœ“"
		
		# Check for pip
		if command_exists pip3; then
			print_status "pip3 found âœ“"
		else
			print_warning "pip3 not found. Python bindings will not be built."
		fi
		
		# Check for maturin
		if command_exists maturin; then
			print_status "maturin found for Python bindings âœ“"
		else
			print_warning "maturin not found. Installing..."
			if command_exists pip3; then
				pip3 install --user maturin
				if command_exists maturin; then
					print_status "maturin installed successfully âœ“"
				else
					print_warning "Failed to install maturin. Python bindings will not be built."
				fi
			fi
		fi
	else
		print_warning "Python 3 not found. Python bindings will not be built."
	fi
	
	# Check for uv (recommended)
	if command_exists uv; then
		print_status "uv found - recommended for Python development âœ“"
	else
		print_warning "uv not found. Consider installing for better Python dependency management."
		print_status "Install with: curl -LsSf https://astral.sh/uv/install.sh | sh"
	fi
}

# Function to check Windows dependencies
check_windows_dependencies() {
	print_substep "Checking Windows dependencies..."
	
	# Check for Visual Studio Build Tools
	if ! command_exists cl.exe; then
		print_warning "Visual Studio Build Tools may not be installed."
		print_status "Please install Visual Studio Build Tools with C++ support."
		print_status "Download from: https://visualstudio.microsoft.com/visual-cpp-build-tools/"
	else
		print_status "Visual Studio Build Tools found âœ“"
	fi
	
	# Check for Python
	if command_exists python; then
		print_status "Python found âœ“"
		
		if command_exists pip; then
			print_status "pip found âœ“"
		else
			print_warning "pip not found. Python bindings will not be built."
		fi
		
		if command_exists maturin; then
			print_status "maturin found for Python bindings âœ“"
		else
			print_warning "maturin not found. Installing..."
			if command_exists pip; then
				pip install --user maturin
				if command_exists maturin; then
					print_status "maturin installed successfully âœ“"
				else
					print_warning "Failed to install maturin. Python bindings will not be built."
				fi
			fi
		fi
	else
		print_warning "Python not found. Python bindings will not be built."
	fi
}

# Function to check Linux dependencies
check_linux_dependencies() {
	print_substep "Checking Linux dependencies..."
	
	# Check for basic build tools
	local missing_tools=()
	
	for tool in gcc g++ make pkg-config; do
		if ! command_exists $tool; then
			missing_tools+=($tool)
		fi
	done
	
	if [ ${#missing_tools[@]} -gt 0 ]; then
		print_warning "Missing build tools: ${missing_tools[*]}"
		print_status "Install with:"
		print_status "  Ubuntu/Debian: sudo apt-get install build-essential pkg-config"
		print_status "  Fedora/RHEL: sudo dnf install gcc gcc-c++ make pkgconfig"
		print_status "  Arch Linux: sudo pacman -S base-devel pkgconf"
	else
		print_status "Build tools found âœ“"
	fi
	
	# Check for font development libraries
	if ! pkg-config --exists fontconfig 2>/dev/null; then
		print_warning "fontconfig development libraries not found."
		print_status "Install with:"
		print_status "  Ubuntu/Debian: sudo apt-get install libfontconfig1-dev"
		print_status "  Fedora/RHEL: sudo dnf install fontconfig-devel"
		print_status "  Arch Linux: sudo pacman -S fontconfig"
	else
		print_status "fontconfig development libraries found âœ“"
	fi
}

# Function to check optional dependencies
check_optional_dependencies() {
	print_substep "Checking optional dependencies..."
	
	# Check for git
	if command_exists git; then
		print_status "git found âœ“"
	else
		print_warning "git not found. Recommended for version control."
	fi
	
	# Check for common development tools
	local tools=("jq" "curl" "wget")
	for tool in "${tools[@]}"; do
		if command_exists $tool; then
			print_status "$tool found âœ“"
		fi
	done
}

# Ensure a virtualenv exists so maturin can install the extension
ensure_python_virtualenv() {
	# Respect existing activations (VIRTUAL_ENV or conda)
	if [ -n "${VIRTUAL_ENV:-}" ]; then
		print_status "Using existing virtualenv at $VIRTUAL_ENV"
		return 0
	fi
	if [ -n "${CONDA_PREFIX:-}" ]; then
		print_status "Using active conda environment at $CONDA_PREFIX"
		return 0
	fi

	local venv_dir="$SCRIPT_DIR/.venv"
	if [ -d "$venv_dir" ]; then
		print_status "Found virtualenv at $venv_dir"
	else
		print_substep "Creating virtualenv at $venv_dir..."
		if command_exists uv; then
			uv venv "$venv_dir"
		else
			local python_bin=""
			if command_exists python3; then
				python_bin="python3"
			elif command_exists python; then
				python_bin="python"
			fi

			if [ -z "$python_bin" ]; then
				print_warning "Python not available to create a virtualenv; skipping Python bindings"
				return 1
			fi

			$python_bin -m venv "$venv_dir"
		fi
	fi

	# Surface the environment for maturin without requiring manual activation
	export VIRTUAL_ENV="$venv_dir"
	export PATH="$VIRTUAL_ENV/bin:$PATH"
	print_status "Virtualenv ready at $VIRTUAL_ENV"
}

# Function to build components
build_component() {
	local component=$1
	local features=$2
	local build_mode=$3
	
	print_step "Building $component..."
	
	local build_flags=""
	if [ "$build_mode" == "release" ]; then
		build_flags="--release"
	fi
	
	cd "$SCRIPT_DIR"
	
	if [ -n "$features" ]; then
		cargo build -p "$component" --features "$features" $build_flags
	else
		cargo build -p "$component" $build_flags
	fi
	
	if [ $? -eq 0 ]; then
		print_status "$component built successfully"
	else
		print_error "Failed to build $component"
		exit 1
	fi
}

# Function to run tests
run_tests() {
	local build_mode=$1
	
	print_step "Running comprehensive tests..."
	
	local test_flags=""
	if [ "$build_mode" == "release" ]; then
		test_flags="--release"
	fi
	
	cd "$SCRIPT_DIR"
	
	# Run unit tests
	print_substep "Running unit tests..."
	cargo test --workspace $test_flags --lib
	if [ $? -eq 0 ]; then
		print_status "Unit tests passed âœ“"
	else
		print_error "Unit tests failed"
		exit 1
	fi
	
	# Run integration tests if they exist
	if [ -d "$SCRIPT_DIR/tests" ]; then
		print_substep "Running integration tests..."
		cargo test --workspace $test_flags --test '*'
		if [ $? -eq 0 ]; then
			print_status "Integration tests passed âœ“"
		else
			print_error "Integration tests failed"
			exit 1
		fi
	fi
	
	# Test CLI functionality
	local cli_path="target/$build_mode/fontlift"
	if [ -f "$SCRIPT_DIR/$cli_path" ]; then
		print_substep "Testing CLI functionality..."
		if "$SCRIPT_DIR/$cli_path" --help >/dev/null 2>&1; then
			print_status "CLI help command works âœ“"
		else
			print_error "CLI help command failed"
			exit 1
		fi
		
		# Test CLI list command
		if "$SCRIPT_DIR/$cli_path" list >/dev/null 2>&1; then
			print_status "CLI list command works âœ“"
		else
			print_warning "CLI list command failed (may be expected without fonts)"
		fi
	else
		print_warning "CLI binary not found at $cli_path"
	fi
	
	# Test Python bindings if built
	local platform_info=$(get_platform_info)
	local dylib_suffix=$(echo "$platform_info" | cut -d: -f3)
	local python_path="target/$build_mode/lib_native$dylib_suffix"
	
	if [ -f "$SCRIPT_DIR/$python_path" ]; then
		print_substep "Testing Python bindings..."
		if command_exists python3; then
			if python3 -c "import sys; sys.path.insert(0, '$SCRIPT_DIR/target/$build_mode'); import fontlift; print('âœ“ Python bindings import successful')" 2>/dev/null; then
				print_status "Python bindings work âœ“"
			else
				print_warning "Python bindings test failed (may need to be installed first)"
			fi
		else
			print_warning "Python 3 not available for testing bindings"
		fi
	fi
}

# Function to build Python bindings
build_python_bindings() {
	local build_mode=$1
	local manifest_path="$SCRIPT_DIR/crates/fontlift-python/Cargo.toml"

	print_step "Building Python bindings..."

	if ! ensure_python_virtualenv; then
		print_warning "Unable to prepare Python virtualenv; skipping Python bindings"
		return
	fi
	
	if command_exists hatch; then
		print_substep "Using hatch to build wheel..."
		uvx hatch build -t wheel
		local wheel
		wheel=$(ls -t dist/fontlift-*.whl 2>/dev/null | head -n1 || true)
		if [ -n "$wheel" ]; then
			uv pip install --force-reinstall "$wheel"
			print_status "Python wheel built and installed âœ“"
		else
			print_warning "Hatch build did not produce a wheel; skipping install"
		fi
		return
	fi

	if ! command_exists maturin; then
		print_warning "hatch/maturin not found, skipping Python bindings"
		return
	fi
	
	if ! command_exists python3 && ! command_exists python; then
		print_warning "Python not found, skipping Python bindings"
		return
	fi
	
	local build_flags=""
	if [ "$build_mode" == "release" ]; then
		build_flags="--release"
	fi
	
	cd "$SCRIPT_DIR"
	
	# Build Python bindings from the Python crate manifest (workspace root lacks a package table)
	maturin develop -m "$manifest_path" $build_flags --features python-bindings
	if [ $? -eq 0 ]; then
		print_status "Python bindings built and installed successfully"
	else
		print_error "Failed to build Python bindings"
		exit 1
	fi
}

# Function to create distribution packages
create_packages() {
	local build_mode=$1
	local platform_info=$(get_platform_info)
	local platform=$(echo "$platform_info" | cut -d: -f1)
	local arch=$(echo "$platform_info" | cut -d: -f2)
	
	print_step "Creating distribution packages..."
	
	cd "$SCRIPT_DIR"
	
	# Create distribution directory
	local dist_dir="dist-$build_mode-$platform-$arch"
	mkdir -p "$dist_dir"
	
	# Package CLI binary
	local cli_path="target/$build_mode/fontlift"
	if [ -f "$cli_path" ]; then
		cp "$cli_path" "$dist_dir/"
		print_status "CLI binary packaged"
	fi
	
	# Package Python wheel if maturin is available
	if [ "$build_mode" == "release" ]; then
		if command_exists hatch; then
			print_substep "Building Python wheel with hatch..."
			if uvx hatch build -t wheel --output "$dist_dir"; then
				print_status "Python wheel created"
			else
				print_warning "Failed to create Python wheel via hatch"
			fi
		elif command_exists maturin; then
			print_substep "Building Python wheel..."
			maturin build -m "$SCRIPT_DIR/crates/fontlift-python/Cargo.toml" --release --out "$dist_dir"
			if [ $? -eq 0 ]; then
				print_status "Python wheel created"
			else
				print_warning "Failed to create Python wheel"
			fi
		fi
	fi
	
	# Copy essential files
	cp README.md "$dist_dir/" 2>/dev/null || true
	cp LICENSE "$dist_dir/" 2>/dev/null || true
	cp USAGE.md "$dist_dir/" 2>/dev/null || true
	
	# Create archive
	local archive_name="fontlift-$platform-$arch-$build_mode.tar.gz"
	tar -czf "$archive_name" -C "$dist_dir" .
	print_status "Distribution archive created: $archive_name"
	
	print_success "Packages created in $dist_dir/"
}

# Function to show usage
show_usage() {
	echo "FontLift Production Build Script"
	echo ""
	echo "Usage: $0 [OPTIONS]"
	echo ""
	echo "Options:"
	echo "  --release         Build in release mode (default: debug)"
	echo "  --test            Run tests after build"
	echo "  --python          Build Python bindings"
	echo "  --cli-only        Build only CLI components"
	echo "  --core-only       Build only core library"
	echo "  --package         Create distribution packages"
	echo "  --clean           Clean build artifacts before building"
	echo "  --check-deps      Only check dependencies, don't build"
	echo "  --verbose         Enable verbose output"
	echo "  --help            Show this help message"
	echo ""
	echo "Examples:"
	echo "  $0 --release --test --python     Full build with tests and Python bindings"
	echo "  $0 --cli-only --test             Quick CLI build with tests"
	echo "  $0 --release --package           Production build with packaging"
	echo "  $0 --check-deps                  Only verify dependencies"
	echo ""
	echo "Environment Variables:"
	echo "  RUST_LOG          Set logging level (debug, info, warn, error)"
	echo "  CARGO_TARGET_DIR  Override target directory"
	echo "  FONTLIFT_PROFILE  Override build profile (debug/release)"
}

# Function to verify installation
verify_installation() {
	local build_mode=$1
	local platform_info=$(get_platform_info)
	local platform=$(echo "$platform_info" | cut -d: -f1)
	local dylib_suffix=$(echo "$platform_info" | cut -d: -f3)
	
	print_step "Verifying installation..."
	
	cd "$SCRIPT_DIR"
	
	# Verify CLI
	local cli_path="target/$build_mode/fontlift"
	if [ -f "$cli_path" ]; then
		print_substep "CLI binary verified at $cli_path"
		
		# Test CLI version
		if "$cli_path" --version >/dev/null 2>&1; then
			print_status "CLI version command works âœ“"
		else
			print_warning "CLI version command failed"
		fi
	else
		print_warning "CLI binary not found"
	fi
	
	# Verify Python bindings
	local python_path="target/$build_mode/lib_native$dylib_suffix"
	if [ -f "$python_path" ]; then
		print_substep "Python bindings verified at $python_path"
	else
		print_warning "Python bindings not found"
	fi
	
	# Show system information
	print_status "Build verification completed"
	print_status "Platform: $platform"
	print_status "Build mode: $build_mode"
	print_status "Installation ready"
}

# Main function
main() {
	print_header
	
	# Parse command line arguments
	local BUILD_MODE="debug"
	local RUN_TESTS="no"
	local BUILD_PYTHON="no"
	local BUILD_CLI="no"
	local BUILD_CORE="no"
	local BUILD_ALL="yes"
	local CREATE_PACKAGES="no"
	local CLEAN_BUILD="no"
	local CHECK_DEPS_ONLY="no"
	local VERBOSE="no"
	
	while [[ $# -gt 0 ]]; do
		case $1 in
		--release)
			BUILD_MODE="release"
			shift
			;;
		--test)
			RUN_TESTS="yes"
			shift
			;;
		--python)
			BUILD_PYTHON="yes"
			BUILD_ALL="no"
			shift
			;;
		--cli-only)
			BUILD_CLI="yes"
			BUILD_ALL="no"
			shift
			;;
		--core-only)
			BUILD_CORE="yes"
			BUILD_ALL="no"
			shift
			;;
		--package)
			CREATE_PACKAGES="yes"
			shift
			;;
		--clean)
			CLEAN_BUILD="yes"
			shift
			;;
		--check-deps)
			CHECK_DEPS_ONLY="yes"
			shift
			;;
		--verbose)
			VERBOSE="yes"
			set -x
			shift
			;;
		-h | --help)
			show_usage
			exit 0
			;;
		*)
			print_error "Unknown option: $1"
			show_usage
			exit 1
			;;
		esac
	done
	
	# Get platform information
	local platform_info=$(get_platform_info)
	local platform=$(echo "$platform_info" | cut -d: -f1)
	local arch=$(echo "$platform_info" | cut -d: -f2)
	
	print_status "Platform: $platform ($arch)"
	
	# Check dependencies
	check_and_install_dependencies
	
	# If only checking dependencies, exit here
	if [ "$CHECK_DEPS_ONLY" == "yes" ]; then
		print_success "All dependencies verified âœ“"
		exit 0
	fi
	
	# Clean build artifacts if requested
	if [ "$CLEAN_BUILD" == "yes" ]; then
		print_step "Cleaning build artifacts..."
		cd "$SCRIPT_DIR"
		cargo clean
		print_status "Build artifacts cleaned"
	fi
	
	print_status "Starting FontLift build process..."
	print_status "Build mode: $BUILD_MODE"
	
	# Build components
	if [ "$BUILD_ALL" == "yes" ] || [ "$BUILD_CORE" == "yes" ]; then
		build_component "fontlift-core" "" "$BUILD_MODE"
	fi
	
	if [ "$BUILD_ALL" == "yes" ] || [ "$BUILD_CLI" == "yes" ]; then
		case $platform in
		macos)
			build_component "fontlift-platform-mac" "" "$BUILD_MODE"
			;;
		windows)
			build_component "fontlift-platform-win" "" "$BUILD_MODE"
			;;
		linux)
			print_warning "Linux platform implementation not yet available"
			;;
		esac
		build_component "fontlift-cli" "" "$BUILD_MODE"
	fi
	
	if [ "$BUILD_ALL" == "yes" ] || [ "$BUILD_PYTHON" == "yes" ]; then
		build_component "fontlift-python" "python-bindings" "$BUILD_MODE"
	fi
	
	# Build Python bindings if requested
	if [ "$BUILD_ALL" == "yes" ] || [ "$BUILD_PYTHON" == "yes" ]; then
		build_python_bindings "$BUILD_MODE"
	fi
	
	# Run tests if requested
	if [ "$RUN_TESTS" == "yes" ]; then
		run_tests "$BUILD_MODE"
	fi
	
	# Create packages if requested
	if [ "$CREATE_PACKAGES" == "yes" ]; then
		create_packages "$BUILD_MODE"
	fi
	
	# Verify installation
	verify_installation "$BUILD_MODE"
	
	# Print build summary
	print_success "Build completed successfully!"
	print_status "Platform: $platform ($arch)"
	print_status "Build mode: $BUILD_MODE"
	
	local dylib_suffix=$(echo "$platform_info" | cut -d: -f3)
	
	if [ "$BUILD_ALL" == "yes" ] || [ "$BUILD_CLI" == "yes" ]; then
		print_status "CLI binary location: target/$BUILD_MODE/fontlift"
	fi
	
	if [ "$BUILD_ALL" == "yes" ] || [ "$BUILD_PYTHON" == "yes" ]; then
		print_status "Python module location: target/$BUILD_MODE/lib_native$dylib_suffix"
	fi
	
	echo ""
	print_status "Next steps:"
	print_status "- Run CLI: ./target/$BUILD_MODE/fontlift --help"
	print_status "- Test Python: python3 -c 'import fontlift; print(fontlift.list_fonts())'"
	print_status "- Read documentation: README.md, USAGE.md"
	
	if [ "$CREATE_PACKAGES" == "yes" ]; then
		print_status "- Distribution packages created in dist-$BUILD_MODE-$platform-$arch/"
	fi
	
	echo ""
	print_success "FontLift is ready for production use! ğŸš€"
}

# Run main function with all arguments
main "$@"
```

## crates/fontlift-cli/Cargo.toml
```toml
[package]
name = "fontlift-cli"
version.workspace = true
authors.workspace = true
edition.workspace = true
rust-version.workspace = true
license.workspace = true
repository.workspace = true
description = "CLI interface for fontlift"

[[bin]]
name = "fontlift"
path = "src/main.rs"

[dependencies]
fontlift-core = { workspace = true }
clap = { workspace = true }
clap_complete = { workspace = true }
thiserror = { workspace = true }
anyhow = { workspace = true }
log = { workspace = true }
env_logger = { workspace = true }
tokio = { workspace = true }
serde = { workspace = true }
serde_json = { workspace = true }

# Platform-specific dependencies
[target.'cfg(target_os = "macos")'.dependencies]
fontlift-platform-mac = { workspace = true }

[target.'cfg(target_os = "windows")'.dependencies]
fontlift-platform-win = { workspace = true }

[dev-dependencies]
tempfile = "3.0"
tokio = { workspace = true, features = ["rt-multi-thread", "macros"] }
serde_json = { workspace = true }
```

# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/crates/fontlift-cli/src/args.rs
# Language: rust

struct Cli {
}


# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/crates/fontlift-cli/src/lib.rs
# Language: rust

mod args;

mod ops;

mod tests;


# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/crates/fontlift-cli/src/main.rs
# Language: rust



# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/crates/fontlift-cli/src/ops.rs
# Language: rust

struct ListRenderOptions {
}

struct OutputOptions {
}

struct OperationOptions {
}


# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/crates/fontlift-cli/src/tests.rs
# Language: rust

struct RecordingManager {
}

struct ScopedUninstallManager {
}

struct DenyCacheManager {
}


## crates/fontlift-cli/tests/macos_fake_registry_tests.rs
```rust
#![cfg(target_os = "macos")]

use std::env;
use std::path::{Path, PathBuf};
use std::sync::{Arc, Mutex};

/// Mutex to serialize tests that modify FONTLIFT_FAKE_REGISTRY_ROOT
static ENV_LOCK: Mutex<()> = Mutex::new(());

use fontlift_cli::{
    handle_doctor_command, handle_install_command, handle_uninstall_command, ListRender,
    ListRenderOptions, OperationOptions, ValidationStrictness,
};
use fontlift_core::{
    journal, validation_ext::ValidatorConfig, FontManager, FontScope, FontliftFontSource,
};
use fontlift_platform_mac::MacFontManager;
use serde_json::Value;
use tempfile::TempDir;

fn workspace_root() -> PathBuf {
    // CARGO_MANIFEST_DIR points to crates/fontlift-cli, go up two levels
    PathBuf::from(env!("CARGO_MANIFEST_DIR"))
        .parent()
        .and_then(|p| p.parent())
        .map(|p| p.to_path_buf())
        .expect("Failed to find workspace root")
}

fn fixture_font() -> PathBuf {
    workspace_root().join("tests/fixtures/fonts/AtkinsonHyperlegible-Regular.ttf")
}

fn fixture_font_otf() -> PathBuf {
    workspace_root().join("tests/fixtures/fonts/AtkinsonHyperlegible-Regular.otf")
}

fn fixture_font_ttc() -> PathBuf {
    workspace_root().join("tests/fixtures/fonts/AtkinsonHyperlegible-Regular.ttc")
}

fn malformed_fixture() -> PathBuf {
    workspace_root().join("tests/fixtures/fonts/malformed.ttf")
}

fn quiet_opts() -> OperationOptions {
    OperationOptions::new(false, true, false)
}

struct EnvGuard {
    key: &'static str,
    previous: Option<std::ffi::OsString>,
}

impl EnvGuard {
    fn set_path(key: &'static str, value: &Path) -> Self {
        let previous = env::var_os(key);
        env::set_var(key, value);
        Self { key, previous }
    }
}

impl Drop for EnvGuard {
    fn drop(&mut self) {
        if let Some(prev) = self.previous.take() {
            env::set_var(self.key, prev);
        } else {
            env::remove_var(self.key);
        }
    }
}

#[tokio::test]
async fn mac_fake_registry_user_scope_round_trip() {
    let _env_lock = ENV_LOCK.lock().expect("env lock");
    let temp_root = TempDir::new().expect("temp dir for fake registry");
    let _guard = EnvGuard::set_path("FONTLIFT_FAKE_REGISTRY_ROOT", temp_root.path());
    let mac_manager = MacFontManager::new();
    assert!(mac_manager.is_fake_registry_enabled());
    let manager: Arc<dyn FontManager> = Arc::new(mac_manager);

    let source_path = fixture_font();
    let target_path = temp_root
        .path()
        .join("Library/Fonts/AtkinsonHyperlegible-Regular.ttf");

    handle_install_command(
        manager.clone(),
        vec![source_path.clone()],
        false,
        false, // validate
        ValidationStrictness::Normal,
        quiet_opts(),
    )
    .await
    .expect("install into fake registry should succeed");

    assert!(target_path.exists(), "font copied into fake registry");
    assert!(
        manager
            .is_font_installed(
                &FontliftFontSource::new(source_path.clone()).with_scope(Some(FontScope::User))
            )
            .expect("is_font_installed should read fake registry"),
        "fake registry reports installation"
    );

    let fonts = manager
        .list_installed_fonts()
        .expect("list should read fake registry");
    assert!(
        fonts
            .iter()
            .any(|f| f.source.path == target_path && f.source.scope == Some(FontScope::User)),
        "listed fonts include the installed user font"
    );

    let rendered = fontlift_cli::render_list_output(
        fonts.clone(),
        ListRenderOptions {
            show_path: true,
            show_name: true,
            sorted: true,
            json: true,
        },
    )
    .expect("render list to JSON");

    if let ListRender::Json(json) = rendered {
        let parsed: Value = serde_json::from_str(&json).expect("valid JSON output");
        let array = parsed.as_array().expect("list renders to array");
        assert!(
            array.iter().any(|entry| {
                entry["source"]["path"]
                    .as_str()
                    .map(|p| p.ends_with("AtkinsonHyperlegible-Regular.ttf"))
                    .unwrap_or(false)
            }),
            "JSON output includes installed font"
        );
    } else {
        panic!("expected JSON render");
    }

    handle_uninstall_command(
        manager.clone(),
        None,
        vec![source_path.clone()],
        false,
        quiet_opts(),
    )
    .await
    .expect("uninstall should remove from fake registry");

    assert!(
        !target_path.exists(),
        "font file removed from fake registry after uninstall"
    );
    assert!(
        !manager
            .is_font_installed(
                &FontliftFontSource::new(source_path).with_scope(Some(FontScope::User))
            )
            .expect("is_font_installed should read fake registry"),
        "fake registry reports font removed"
    );
}

#[tokio::test]
async fn mac_fake_registry_system_scope_without_admin() {
    let _env_lock = ENV_LOCK.lock().expect("env lock");
    let temp_root = TempDir::new().expect("temp dir for fake registry");
    let _guard = EnvGuard::set_path("FONTLIFT_FAKE_REGISTRY_ROOT", temp_root.path());
    let manager: Arc<dyn FontManager> = Arc::new(MacFontManager::new());

    let source_path = fixture_font();
    let system_target = temp_root
        .path()
        .join("System/Library/Fonts/AtkinsonHyperlegible-Regular.ttf");

    handle_install_command(
        manager.clone(),
        vec![source_path.clone()],
        true,
        false, // validate
        ValidationStrictness::Normal,
        quiet_opts(),
    )
    .await
    .expect("system-scope install should be allowed in fake registry");
    assert!(
        system_target.exists(),
        "system font copied into fake registry"
    );

    handle_uninstall_command(
        manager.clone(),
        None,
        vec![source_path.clone()],
        true,
        quiet_opts(),
    )
    .await
    .expect("system-scope uninstall should clean fake registry");
    assert!(
        !system_target.exists(),
        "system font removed from fake registry"
    );
}

/// Test that malformed fonts are rejected when CLI validation is enabled
#[tokio::test]
async fn mac_fake_registry_rejects_malformed_font_with_validation() {
    let _env_lock = ENV_LOCK.lock().expect("env lock");
    let temp_root = TempDir::new().expect("temp dir for fake registry");
    let _guard = EnvGuard::set_path("FONTLIFT_FAKE_REGISTRY_ROOT", temp_root.path());
    let manager: Arc<dyn FontManager> = Arc::new(MacFontManager::new());

    let malformed_path = malformed_fixture();
    assert!(malformed_path.exists(), "malformed fixture must exist");

    // Install with validation enabled should fail
    let result = handle_install_command(
        manager.clone(),
        vec![malformed_path.clone()],
        false,
        true, // validate=true
        ValidationStrictness::Normal,
        quiet_opts(),
    )
    .await;

    assert!(
        result.is_err(),
        "installing malformed font with validation should fail"
    );

    let err_msg = result.unwrap_err().to_string();
    // The validator should reject the font
    assert!(
        err_msg.contains("Invalid") || err_msg.contains("validation") || err_msg.contains("parse"),
        "error should indicate validation failure: {err_msg}"
    );

    // Font should NOT be installed
    let target_path = temp_root.path().join("Library/Fonts/malformed.ttf");
    assert!(
        !target_path.exists(),
        "malformed font should not be copied to fake registry"
    );
}

/// Test that malformed fonts CAN be installed when validation is disabled
#[tokio::test]
async fn mac_fake_registry_accepts_malformed_font_without_validation() {
    let _env_lock = ENV_LOCK.lock().expect("env lock");
    let temp_root = TempDir::new().expect("temp dir for fake registry");
    let _guard = EnvGuard::set_path("FONTLIFT_FAKE_REGISTRY_ROOT", temp_root.path());
    let manager: Arc<dyn FontManager> = Arc::new(MacFontManager::new());

    let malformed_path = malformed_fixture();
    assert!(malformed_path.exists(), "malformed fixture must exist");

    // Install with validation disabled should succeed (at CLI level, Core Text may still reject)
    let result = handle_install_command(
        manager.clone(),
        vec![malformed_path.clone()],
        false,
        false, // validate=false
        ValidationStrictness::Normal,
        quiet_opts(),
    )
    .await;

    // The fake registry will accept the file even if it's malformed
    // (Real Core Text would reject it, but fake registry just copies files)
    assert!(
        result.is_ok(),
        "installing malformed font without validation should succeed in fake registry: {:?}",
        result.err()
    );

    let target_path = temp_root.path().join("Library/Fonts/malformed.ttf");
    assert!(
        target_path.exists(),
        "malformed font should be copied to fake registry when validation disabled"
    );
}

/// Test that the manager-level validation rejects malformed fonts
#[tokio::test]
async fn mac_manager_with_validation_rejects_malformed_font() {
    let _env_lock = ENV_LOCK.lock().expect("env lock");
    let temp_root = TempDir::new().expect("temp dir for fake registry");
    let _guard = EnvGuard::set_path("FONTLIFT_FAKE_REGISTRY_ROOT", temp_root.path());

    // Create manager WITH validation enabled
    let manager = MacFontManager::with_validation(ValidatorConfig::default());

    let malformed_path = malformed_fixture();
    let source = FontliftFontSource::new(malformed_path.clone()).with_scope(Some(FontScope::User));

    let result = manager.install_font(&source);

    assert!(
        result.is_err(),
        "manager with validation should reject malformed font"
    );

    let target_path = temp_root.path().join("Library/Fonts/malformed.ttf");
    assert!(
        !target_path.exists(),
        "malformed font should not be installed"
    );
}

/// Golden output test: validates exact JSON schema for list --json output
#[tokio::test]
async fn mac_fake_registry_list_json_golden_output() {
    let _env_lock = ENV_LOCK.lock().expect("env lock");
    let temp_root = TempDir::new().expect("temp dir for fake registry");
    let _guard = EnvGuard::set_path("FONTLIFT_FAKE_REGISTRY_ROOT", temp_root.path());
    let mac_manager = MacFontManager::new();
    let manager: Arc<dyn FontManager> = Arc::new(mac_manager);

    // Install the fixture font
    let source_path = fixture_font();
    handle_install_command(
        manager.clone(),
        vec![source_path.clone()],
        false,
        false,
        ValidationStrictness::Normal,
        quiet_opts(),
    )
    .await
    .expect("install should succeed");

    // List and render as JSON
    let fonts = manager.list_installed_fonts().expect("list");
    let rendered = fontlift_cli::render_list_output(
        fonts,
        ListRenderOptions {
            show_path: true,
            show_name: true,
            sorted: true,
            json: true,
        },
    )
    .expect("render");

    let ListRender::Json(json) = rendered else {
        panic!("expected JSON output");
    };

    // Parse and validate schema
    let parsed: Vec<Value> = serde_json::from_str(&json).expect("valid JSON array");
    assert_eq!(parsed.len(), 1, "should have exactly one font installed");

    let font = &parsed[0];

    // Validate required fields exist and have correct types
    assert!(
        font["postscript_name"].is_string(),
        "postscript_name should be string"
    );
    assert!(font["full_name"].is_string(), "full_name should be string");
    assert!(
        font["family_name"].is_string(),
        "family_name should be string"
    );
    assert!(font["style"].is_string(), "style should be string");
    assert!(font["source"].is_object(), "source should be object");
    assert!(
        font["source"]["path"].is_string(),
        "source.path should be string"
    );

    // Validate source.path points to correct location
    let path = font["source"]["path"].as_str().unwrap();
    assert!(
        path.ends_with("AtkinsonHyperlegible-Regular.ttf"),
        "path should end with font filename, got: {path}"
    );
    assert!(
        path.contains("Library/Fonts"),
        "path should be in Library/Fonts, got: {path}"
    );

    // Validate scope is present and correct (capitalized per Rust enum serialization)
    assert_eq!(
        font["source"]["scope"].as_str(),
        Some("User"),
        "scope should be 'User'"
    );

    // Validate format field if present (capitalized per Rust enum serialization)
    if let Some(format) = font["source"]["format"].as_str() {
        assert!(
            ["TTF", "OTF", "TTC", "OTC", "WOFF", "WOFF2", "DFont", "Unknown"].contains(&format),
            "format should be valid font format, got: {format}"
        );
    }

    // Validate optional numeric fields have correct types when present
    if !font["weight"].is_null() {
        assert!(
            font["weight"].is_number(),
            "weight should be number if present"
        );
    }
    if !font["italic"].is_null() {
        assert!(
            font["italic"].is_boolean(),
            "italic should be boolean if present"
        );
    }
}

/// Test OTF format installation and JSON output
#[tokio::test]
async fn mac_fake_registry_otf_format_golden_output() {
    let _env_lock = ENV_LOCK.lock().expect("env lock");
    let temp_root = TempDir::new().expect("temp dir for fake registry");
    let _guard = EnvGuard::set_path("FONTLIFT_FAKE_REGISTRY_ROOT", temp_root.path());
    let mac_manager = MacFontManager::new();
    let manager: Arc<dyn FontManager> = Arc::new(mac_manager);

    let source_path = fixture_font_otf();
    assert!(source_path.exists(), "OTF fixture must exist");

    handle_install_command(
        manager.clone(),
        vec![source_path.clone()],
        false,
        false,
        ValidationStrictness::Normal,
        quiet_opts(),
    )
    .await
    .expect("OTF install should succeed");

    let fonts = manager.list_installed_fonts().expect("list");
    let rendered = fontlift_cli::render_list_output(
        fonts,
        ListRenderOptions {
            show_path: true,
            show_name: true,
            sorted: true,
            json: true,
        },
    )
    .expect("render");

    let ListRender::Json(json) = rendered else {
        panic!("expected JSON output");
    };

    let parsed: Vec<Value> = serde_json::from_str(&json).expect("valid JSON array");
    assert_eq!(
        parsed.len(),
        1,
        "should have exactly one OTF font installed"
    );

    let font = &parsed[0];
    let path = font["source"]["path"].as_str().unwrap();
    assert!(
        path.ends_with("AtkinsonHyperlegible-Regular.otf"),
        "path should end with .otf, got: {path}"
    );

    // OTF format should be detected
    assert_eq!(
        font["source"]["format"].as_str(),
        Some("OTF"),
        "format should be OTF"
    );
}

/// Test TTC (font collection) format installation and JSON output
#[tokio::test]
async fn mac_fake_registry_ttc_format_golden_output() {
    let _env_lock = ENV_LOCK.lock().expect("env lock");
    let temp_root = TempDir::new().expect("temp dir for fake registry");
    let _guard = EnvGuard::set_path("FONTLIFT_FAKE_REGISTRY_ROOT", temp_root.path());
    let mac_manager = MacFontManager::new();
    let manager: Arc<dyn FontManager> = Arc::new(mac_manager);

    let source_path = fixture_font_ttc();
    assert!(source_path.exists(), "TTC fixture must exist");

    handle_install_command(
        manager.clone(),
        vec![source_path.clone()],
        false,
        false,
        ValidationStrictness::Normal,
        quiet_opts(),
    )
    .await
    .expect("TTC install should succeed");

    let fonts = manager.list_installed_fonts().expect("list");
    let rendered = fontlift_cli::render_list_output(
        fonts,
        ListRenderOptions {
            show_path: true,
            show_name: true,
            sorted: true,
            json: true,
        },
    )
    .expect("render");

    let ListRender::Json(json) = rendered else {
        panic!("expected JSON output");
    };

    let parsed: Vec<Value> = serde_json::from_str(&json).expect("valid JSON array");
    // TTC may contain multiple fonts, should have at least one
    assert!(!parsed.is_empty(), "should have at least one font from TTC");

    let font = &parsed[0];
    let path = font["source"]["path"].as_str().unwrap();
    assert!(
        path.ends_with("AtkinsonHyperlegible-Regular.ttc"),
        "path should end with .ttc, got: {path}"
    );

    // TTC format should be detected
    assert_eq!(
        font["source"]["format"].as_str(),
        Some("TTC"),
        "format should be TTC"
    );
}

/// Test doctor command finds incomplete journal entries
#[tokio::test]
async fn mac_fake_registry_doctor_finds_incomplete_operations() {
    let _env_lock = ENV_LOCK.lock().expect("env lock");
    let temp_root = TempDir::new().expect("temp dir for fake registry");
    let _guard = EnvGuard::set_path("FONTLIFT_FAKE_REGISTRY_ROOT", temp_root.path());

    // Create an incomplete journal entry
    let mut test_journal = journal::Journal::new();
    let actions = vec![
        journal::JournalAction::CopyFile {
            from: fixture_font(),
            to: temp_root.path().join("Library/Fonts/test-font.ttf"),
        },
        journal::JournalAction::RegisterFont {
            path: temp_root.path().join("Library/Fonts/test-font.ttf"),
            scope: FontScope::User,
        },
    ];
    test_journal.record_operation(actions, Some("Test install operation".to_string()));

    // Save the incomplete journal
    journal::save_journal(&test_journal).expect("save journal");

    // Verify doctor command succeeds in preview mode (dry-run)
    let result = handle_doctor_command(true, quiet_opts()).await;
    assert!(
        result.is_ok(),
        "doctor command preview should succeed: {:?}",
        result.err()
    );

    // Verify the journal still has the incomplete entry (preview doesn't modify)
    let reloaded = journal::load_journal().expect("reload journal");
    assert_eq!(
        reloaded.incomplete_entries().len(),
        1,
        "preview mode should not modify journal"
    );
}

/// Test doctor command reports no issues when journal is clean
#[tokio::test]
async fn mac_fake_registry_doctor_clean_journal() {
    let _env_lock = ENV_LOCK.lock().expect("env lock");
    let temp_root = TempDir::new().expect("temp dir for fake registry");
    let _guard = EnvGuard::set_path("FONTLIFT_FAKE_REGISTRY_ROOT", temp_root.path());

    // Create an empty journal (or just don't create one at all)
    let result = handle_doctor_command(false, quiet_opts()).await;
    assert!(
        result.is_ok(),
        "doctor command on clean system should succeed: {:?}",
        result.err()
    );

    // Verify journal is empty or doesn't exist
    let loaded = journal::load_journal().expect("load journal");
    assert!(
        loaded.incomplete_entries().is_empty(),
        "no incomplete entries expected"
    );
}

/// Test doctor command recovers incomplete file copy operation (simulated crash)
#[tokio::test]
async fn mac_fake_registry_doctor_recovers_incomplete_copy() {
    let _env_lock = ENV_LOCK.lock().expect("env lock");
    let temp_root = TempDir::new().expect("temp dir for fake registry");
    let _guard = EnvGuard::set_path("FONTLIFT_FAKE_REGISTRY_ROOT", temp_root.path());

    // Setup: create target directory
    let target_dir = temp_root.path().join("Library/Fonts");
    std::fs::create_dir_all(&target_dir).expect("create fonts dir");

    let source_font = fixture_font();
    let target_font = target_dir.join("recovered-font.ttf");

    // Simulate crash: journal says to copy file, but copy never happened
    let mut test_journal = journal::Journal::new();
    let actions = vec![journal::JournalAction::CopyFile {
        from: source_font.clone(),
        to: target_font.clone(),
    }];
    test_journal.record_operation(actions, Some("Simulated interrupted install".to_string()));
    journal::save_journal(&test_journal).expect("save journal");

    // Verify file doesn't exist yet
    assert!(
        !target_font.exists(),
        "target should not exist before recovery"
    );

    // Run doctor (non-preview mode) to trigger recovery
    let result = handle_doctor_command(false, quiet_opts()).await;
    assert!(
        result.is_ok(),
        "doctor command should succeed: {:?}",
        result.err()
    );

    // Verify file was copied by recovery
    assert!(
        target_font.exists(),
        "doctor should have recovered the file copy"
    );

    // Verify journal entry is now complete
    let reloaded = journal::load_journal().expect("reload journal");
    assert!(
        reloaded.incomplete_entries().is_empty(),
        "journal should have no incomplete entries after recovery"
    );
}

/// Test that validates JSON output can be captured and compared for regression testing
#[tokio::test]
async fn mac_fake_registry_golden_output_capture() {
    let _env_lock = ENV_LOCK.lock().expect("env lock");
    let temp_root = TempDir::new().expect("temp dir for fake registry");
    let _guard = EnvGuard::set_path("FONTLIFT_FAKE_REGISTRY_ROOT", temp_root.path());
    let mac_manager = MacFontManager::new();
    let manager: Arc<dyn FontManager> = Arc::new(mac_manager);

    // Install a known fixture font
    let source_path = fixture_font();
    handle_install_command(
        manager.clone(),
        vec![source_path.clone()],
        false,
        false,
        ValidationStrictness::Normal,
        quiet_opts(),
    )
    .await
    .expect("install should succeed");

    // Capture JSON output
    let fonts = manager.list_installed_fonts().expect("list");
    let rendered = fontlift_cli::render_list_output(
        fonts,
        ListRenderOptions {
            show_path: true,
            show_name: true,
            sorted: true,
            json: true,
        },
    )
    .expect("render");

    let ListRender::Json(json) = rendered else {
        panic!("expected JSON output");
    };

    // Write golden output to temp file for inspection
    let golden_path = temp_root.path().join("golden_output.json");
    std::fs::write(&golden_path, &json).expect("write golden output");

    // Parse to verify structure
    let parsed: Vec<Value> = serde_json::from_str(&json).expect("valid JSON array");
    assert_eq!(parsed.len(), 1, "should have exactly one font");

    // Verify deterministic output (same input produces same output)
    let fonts2 = manager.list_installed_fonts().expect("list again");
    let rendered2 = fontlift_cli::render_list_output(
        fonts2,
        ListRenderOptions {
            show_path: true,
            show_name: true,
            sorted: true,
            json: true,
        },
    )
    .expect("render again");

    let ListRender::Json(json2) = rendered2 else {
        panic!("expected JSON output");
    };

    assert_eq!(
        json, json2,
        "JSON output should be deterministic across calls"
    );
}

/// Test doctor command handles incomplete delete operation (rollforward)
#[tokio::test]
async fn mac_fake_registry_doctor_recovers_incomplete_delete() {
    let _env_lock = ENV_LOCK.lock().expect("env lock");
    let temp_root = TempDir::new().expect("temp dir for fake registry");
    let _guard = EnvGuard::set_path("FONTLIFT_FAKE_REGISTRY_ROOT", temp_root.path());

    // Setup: create a file that should have been deleted
    let target_dir = temp_root.path().join("Library/Fonts");
    std::fs::create_dir_all(&target_dir).expect("create fonts dir");
    let orphan_file = target_dir.join("orphan-font.ttf");
    std::fs::copy(fixture_font(), &orphan_file).expect("create orphan file");

    // Simulate crash: journal says to delete file, but delete never happened
    let mut test_journal = journal::Journal::new();
    let actions = vec![journal::JournalAction::DeleteFile {
        path: orphan_file.clone(),
    }];
    test_journal.record_operation(actions, Some("Simulated interrupted remove".to_string()));
    journal::save_journal(&test_journal).expect("save journal");

    // Verify file exists before recovery
    assert!(
        orphan_file.exists(),
        "orphan file should exist before recovery"
    );

    // Run doctor to trigger recovery
    let result = handle_doctor_command(false, quiet_opts()).await;
    assert!(
        result.is_ok(),
        "doctor command should succeed: {:?}",
        result.err()
    );

    // Verify file was deleted by recovery
    assert!(
        !orphan_file.exists(),
        "doctor should have deleted the orphan file"
    );

    // Verify journal entry is now complete
    let reloaded = journal::load_journal().expect("reload journal");
    assert!(
        reloaded.incomplete_entries().is_empty(),
        "journal should have no incomplete entries after recovery"
    );
}
```

## crates/fontlift-core/Cargo.toml
```toml
[package]
name = "fontlift-core"
version.workspace = true
authors.workspace = true
edition.workspace = true
rust-version.workspace = true
license.workspace = true
repository.workspace = true
description = "Core font management library for fontlift"

[dependencies]
thiserror.workspace = true
anyhow.workspace = true
log.workspace = true
serde.workspace = true
serde_json.workspace = true
tokio.workspace = true
uuid.workspace = true
dirs = "5.0"

# Font loading
read-fonts = "0.36"

[dev-dependencies]
tokio-test = "0.4"
tempfile = "3.0"
```

# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/crates/fontlift-core/src/config.rs
# Language: rust

mod tests;

struct FontliftConfig {
}

struct FontPaths {
}

struct Permissions {
}

struct Logging {
}

struct Performance {
}


# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/crates/fontlift-core/src/journal.rs
# Language: rust

mod systemtime_serde;

mod tests;

struct JournalEntry {
}

struct Journal {
}

struct ActionRecoveryResult {
}


## crates/fontlift-core/src/lib.rs
```rust
//! fontlift-core - Core font management library for fontlift
//!
//! This library provides the core abstractions and types for cross-platform
//! font management, including the FontManager trait and common data structures.

use std::path::PathBuf;
use thiserror::Error;

/// Core errors for font management operations
#[derive(Error, Debug)]
pub enum FontError {
    #[error("Font file not found: {0}\nâ†’ Suggestion: Check the file path and ensure the font file exists")]
    FontNotFound(PathBuf),

    #[error("Invalid font format: {0}\nâ†’ Suggestion: Ensure the file is a valid font (.ttf, .otf, .woff, etc.)")]
    InvalidFormat(String),

    #[error("Font registration failed: {0}\nâ†’ Suggestion: Try restarting your system or using administrator/sudo privileges")]
    RegistrationFailed(String),

    #[error("System font protection: cannot modify system font {0}\nâ†’ Suggestion: System fonts are protected for stability. Use user-level installation instead.")]
    SystemFontProtection(PathBuf),

    #[error("IO error: {0}\nâ†’ Suggestion: Check file permissions and disk space")]
    IoError(#[from] std::io::Error),

    #[error("Permission denied: {0}\nâ†’ Suggestion: Run with administrator privileges on Windows or use sudo on macOS")]
    PermissionDenied(String),

    #[error("Font already installed: {0}\nâ†’ Suggestion: Use 'fontlift uninstall' first if you want to reinstall the font")]
    AlreadyInstalled(PathBuf),

    #[error("Unsupported operation: {0}\nâ†’ Suggestion: This feature may not be available on your platform or in this version")]
    UnsupportedOperation(String),
}

/// Result type for font operations
pub type FontResult<T> = Result<T, FontError>;

/// Font installation scope
#[derive(Debug, Clone, Copy, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum FontScope {
    /// User-level installation (affects only current user)
    User,
    /// System-level installation (affects all users, requires admin)
    System,
}

impl FontScope {
    /// Get a human-readable description
    pub fn description(self) -> &'static str {
        match self {
            FontScope::User => "user-level",
            FontScope::System => "system-level",
        }
    }
}

/// Reference to a font container (file, TTC index, optional scope hint)
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FontliftFontSource {
    /// Path to the font file
    pub path: PathBuf,
    /// Font format (TrueType, OpenType, etc.)
    pub format: Option<String>,
    /// Optional face index for collections
    pub face_index: Option<u32>,
    /// Whether the source is a collection
    pub is_collection: Option<bool>,
    /// Optional installation scope hint
    pub scope: Option<FontScope>,
}

impl FontliftFontSource {
    pub fn new(path: PathBuf) -> Self {
        Self {
            path,
            format: None,
            face_index: None,
            is_collection: None,
            scope: None,
        }
    }

    pub fn with_format(mut self, format: Option<String>) -> Self {
        self.format = format;
        self
    }

    pub fn with_face_index(mut self, index: Option<u32>) -> Self {
        self.face_index = index;
        self
    }

    pub fn with_collection_flag(mut self, is_collection: Option<bool>) -> Self {
        self.is_collection = is_collection;
        self
    }

    pub fn with_scope(mut self, scope: Option<FontScope>) -> Self {
        self.scope = scope;
        self
    }

    pub fn scope_or(self, default: FontScope) -> FontScope {
        self.scope.unwrap_or(default)
    }
}

/// Font face metadata paired with its source
#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct FontliftFontFaceInfo {
    /// Source (path + format + optional scope/index)
    pub source: FontliftFontSource,

    /// PostScript name of the font
    pub postscript_name: String,

    /// Full display name
    pub full_name: String,

    /// Font family name
    pub family_name: String,

    /// Font style/subfamily name
    pub style: String,

    /// Font weight (100-900)
    pub weight: Option<u16>,

    /// Whether font is italic
    pub italic: Option<bool>,
}

impl FontliftFontFaceInfo {
    /// Create a new font face info with basic information
    pub fn new(
        source: FontliftFontSource,
        postscript_name: String,
        full_name: String,
        family_name: String,
        style: String,
    ) -> Self {
        Self {
            source,
            postscript_name,
            full_name,
            family_name,
            style,
            weight: None,
            italic: None,
        }
    }

    /// Get filename without extension
    pub fn filename_stem(&self) -> Option<&str> {
        self.source.path.file_stem()?.to_str()
    }

    /// Attach an installation scope hint to the underlying source
    pub fn with_scope(mut self, scope: Option<FontScope>) -> Self {
        self.source.scope = scope;
        self
    }
}

/// Font manager trait that must be implemented by each platform
pub trait FontManager: Send + Sync {
    /// Install a font file at the specified scope
    fn install_font(&self, source: &FontliftFontSource) -> FontResult<()>;

    /// Uninstall a font (remove from system but keep file)
    fn uninstall_font(&self, source: &FontliftFontSource) -> FontResult<()>;

    /// Remove a font (uninstall and delete file)
    fn remove_font(&self, source: &FontliftFontSource) -> FontResult<()>;

    /// Check if a font is installed
    fn is_font_installed(&self, source: &FontliftFontSource) -> FontResult<bool>;

    /// List all installed fonts
    fn list_installed_fonts(&self) -> FontResult<Vec<FontliftFontFaceInfo>>;

    /// Clear font caches
    fn clear_font_caches(&self, scope: FontScope) -> FontResult<()>;

    /// Prune registrations that point to missing or invalid font files.
    /// Default implementation performs no pruning.
    fn prune_missing_fonts(&self, _scope: FontScope) -> FontResult<usize> {
        Ok(0)
    }
}

/// Font validation utilities
pub mod validation {
    use super::*;
    use std::path::Path;

    /// Check if file has a valid font extension
    pub fn is_valid_font_extension(path: &Path) -> bool {
        if let Some(extension) = path.extension() {
            if let Some(ext_str) = extension.to_str() {
                matches!(
                    ext_str.to_lowercase().as_str(),
                    "ttf" | "otf" | "ttc" | "otc" | "woff" | "woff2" | "dfont"
                )
            } else {
                false
            }
        } else {
            false
        }
    }

    /// Validate font file exists and is readable
    pub fn validate_font_file(path: &Path) -> FontResult<()> {
        if !path.exists() {
            return Err(FontError::FontNotFound(path.to_path_buf()));
        }

        if !path.is_file() {
            return Err(FontError::InvalidFormat("Path is not a file".to_string()));
        }

        if !is_valid_font_extension(path) {
            return Err(FontError::InvalidFormat(
                "Invalid font extension".to_string(),
            ));
        }

        // Check if file is readable
        std::fs::metadata(path).map_err(FontError::IoError)?;

        Ok(())
    }

    /// Extract basic font information from filename (fallback method)
    pub fn extract_basic_info_from_path(path: &Path) -> FontliftFontFaceInfo {
        let filename_stem = path
            .file_stem()
            .and_then(|n| n.to_str())
            .unwrap_or("Unknown")
            .to_string();

        // Simple heuristics for family/style separation
        let (family, style) = if let Some(hyphen_pos) = filename_stem.rfind('-') {
            let family = filename_stem[..hyphen_pos].trim().to_string();
            let style = filename_stem[hyphen_pos + 1..].trim().to_string();
            (family, style)
        } else if let Some(space_pos) = filename_stem.rfind(' ') {
            let family = filename_stem[..space_pos].trim().to_string();
            let style = filename_stem[space_pos + 1..].trim().to_string();
            (family, style)
        } else {
            (filename_stem.clone(), "Regular".to_string())
        };

        let format = path
            .extension()
            .and_then(|ext| ext.to_str())
            .map(|ext| ext.to_uppercase());

        let source = FontliftFontSource::new(path.to_path_buf()).with_format(format);

        FontliftFontFaceInfo::new(source, filename_stem.clone(), filename_stem, family, style)
    }
}

/// Extended validation via out-of-process validator
pub mod validation_ext;

/// Transactional operation journal for crash-safe operations
pub mod journal;

/// Font cache management utilities
pub mod cache {

    /// Cache clearing strategy
    #[derive(Debug, Clone)]
    pub enum CacheClearStrategy {
        /// Clear only user caches
        UserOnly,
        /// Clear only system caches (requires admin)
        SystemOnly,
        /// Clear both user and system caches
        Both,
    }

    /// Result of cache clearing operation
    #[derive(Debug, Clone)]
    pub struct CacheClearResult {
        /// Number of cache entries cleared
        pub entries_cleared: usize,
        /// Whether system restart is required
        pub restart_required: bool,
        /// Any warnings that occurred
        pub warnings: Vec<String>,
    }

    impl CacheClearResult {
        pub fn success(entries_cleared: usize, restart_required: bool) -> Self {
            Self {
                entries_cleared,
                restart_required,
                warnings: Vec::new(),
            }
        }

        pub fn with_warning(mut self, warning: String) -> Self {
            self.warnings.push(warning);
            self
        }
    }
}

/// Helpers for system font protection and duplicate handling
pub mod protection {
    use super::FontliftFontFaceInfo;
    use std::path::Path;

    /// Normalize a path for comparison across platforms (lowercase, forward slashes)
    fn normalize(path: &Path) -> String {
        let mut normalized = path.to_string_lossy().replace('\\', "/").to_lowercase();

        // Collapse duplicate separators that can result from Windows-style paths on POSIX hosts
        while normalized.contains("//") {
            normalized = normalized.replace("//", "/");
        }

        normalized
    }

    /// Detect whether the path points to a protected system font location.
    /// Covers common macOS and Windows system font directories.
    pub fn is_protected_system_font_path(path: &Path) -> bool {
        let normalized = normalize(path);

        normalized.starts_with("/system/library/fonts/")
            || normalized.starts_with("/library/fonts/")
            || normalized.starts_with("c:/windows/fonts/")
    }

    /// Deduplicate fonts deterministically by PostScript name (case-insensitive)
    /// and path (case-insensitive), returning a sorted list.
    pub fn dedupe_fonts(mut fonts: Vec<FontliftFontFaceInfo>) -> Vec<FontliftFontFaceInfo> {
        fonts.sort_by(|a, b| {
            let name_a = a.postscript_name.to_lowercase();
            let name_b = b.postscript_name.to_lowercase();
            let path_a = normalize(&a.source.path);
            let path_b = normalize(&b.source.path);
            (name_a, path_a).cmp(&(name_b, path_b))
        });

        fonts.dedup_by(|a, b| {
            a.postscript_name.eq_ignore_ascii_case(&b.postscript_name)
                && normalize(&a.source.path) == normalize(&b.source.path)
        });

        fonts
    }

    // Re-export for shared conflict detection helpers without exposing normalization publicly
    pub(crate) fn normalize_for_tests(path: &Path) -> String {
        normalize(path)
    }
}

/// Conflict detection helpers shared across platforms.
pub mod conflicts {
    use super::*;
    use std::collections::BTreeSet;
    use std::path::Path;

    fn normalize(path: &Path) -> String {
        protection::normalize_for_tests(path)
    }

    /// Detect conflicting fonts by path, PostScript name, or family+style (case-insensitive).
    /// Returns unique references to installed fonts that should be removed or updated
    /// before installing `candidate`.
    pub fn detect_conflicts<'a>(
        installed: &'a [FontliftFontFaceInfo],
        candidate: &FontliftFontFaceInfo,
    ) -> Vec<&'a FontliftFontFaceInfo> {
        let candidate_path = normalize(&candidate.source.path);
        let candidate_post = candidate.postscript_name.to_lowercase();
        let candidate_family = candidate.family_name.to_lowercase();
        let candidate_style = candidate.style.to_lowercase();

        let mut seen_paths = BTreeSet::new();

        installed
            .iter()
            .filter(|font| {
                let path = normalize(&font.source.path);
                let same_path = path == candidate_path;
                let same_post = font.postscript_name.eq_ignore_ascii_case(&candidate_post);
                let same_family_style = font.family_name.eq_ignore_ascii_case(&candidate_family)
                    && font.style.eq_ignore_ascii_case(&candidate_style);

                same_path || same_post || same_family_style
            })
            .filter(|font| {
                // guarantee unique paths in output for predictable handling
                seen_paths.insert(normalize(&font.source.path))
            })
            .collect()
    }
}

/// Default font manager implementation that returns "not implemented" errors
#[derive(Debug)]
pub struct DummyFontManager;

impl FontManager for DummyFontManager {
    fn install_font(&self, _source: &FontliftFontSource) -> FontResult<()> {
        Err(FontError::UnsupportedOperation(
            "Font installation not implemented for this platform".to_string(),
        ))
    }

    fn uninstall_font(&self, _source: &FontliftFontSource) -> FontResult<()> {
        Err(FontError::UnsupportedOperation(
            "Font uninstallation not implemented for this platform".to_string(),
        ))
    }

    fn remove_font(&self, _source: &FontliftFontSource) -> FontResult<()> {
        Err(FontError::UnsupportedOperation(
            "Font removal not implemented for this platform".to_string(),
        ))
    }

    fn is_font_installed(&self, _source: &FontliftFontSource) -> FontResult<bool> {
        Err(FontError::UnsupportedOperation(
            "Font installation check not implemented for this platform".to_string(),
        ))
    }

    fn list_installed_fonts(&self) -> FontResult<Vec<FontliftFontFaceInfo>> {
        Err(FontError::UnsupportedOperation(
            "Font listing not implemented for this platform".to_string(),
        ))
    }

    fn clear_font_caches(&self, _scope: FontScope) -> FontResult<()> {
        Err(FontError::UnsupportedOperation(
            "Cache clearing not implemented for this platform".to_string(),
        ))
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::path::PathBuf;

    #[test]
    fn detects_protected_system_font_paths() {
        let mac_system = PathBuf::from("/System/Library/Fonts/SFNS.ttf");
        let mac_library = PathBuf::from("/Library/Fonts/Helvetica.ttc");
        let mac_user = PathBuf::from("/Users/example/Library/Fonts/Custom.otf");

        assert!(protection::is_protected_system_font_path(&mac_system));
        assert!(protection::is_protected_system_font_path(&mac_library));
        assert!(!protection::is_protected_system_font_path(&mac_user));

        let win_system = PathBuf::from(r"C:\\Windows\\Fonts\\Arial.ttf");
        let win_subdir = PathBuf::from(r"C:\\Windows\\Fonts\\TrueType\\ComicSans.ttf");
        let win_user = PathBuf::from(r"D:\\Users\\me\\Fonts\\MyFont.ttf");

        assert!(protection::is_protected_system_font_path(&win_system));
        assert!(protection::is_protected_system_font_path(&win_subdir));
        assert!(!protection::is_protected_system_font_path(&win_user));
    }

    #[test]
    fn deduplication_is_deterministic_by_name_and_path() {
        let fonts = vec![
            FontliftFontFaceInfo::new(
                FontliftFontSource::new(PathBuf::from("/fonts/Beta.ttf")),
                "Beta".into(),
                "Beta".into(),
                "BetaFamily".into(),
                "Regular".into(),
            ),
            FontliftFontFaceInfo::new(
                FontliftFontSource::new(PathBuf::from("/fonts/alpha.ttf")),
                "Alpha".into(),
                "Alpha".into(),
                "AlphaFamily".into(),
                "Regular".into(),
            ),
            // duplicate same name/path differing only in case
            FontliftFontFaceInfo::new(
                FontliftFontSource::new(PathBuf::from("/fonts/alpha.ttf")),
                "alpha".into(),
                "alpha".into(),
                "AlphaFamily".into(),
                "Regular".into(),
            ),
            // same name different path should keep both but order deterministic
            FontliftFontFaceInfo::new(
                FontliftFontSource::new(PathBuf::from("/fonts/alpha-bold.ttf")),
                "Alpha".into(),
                "Alpha".into(),
                "AlphaFamily".into(),
                "Bold".into(),
            ),
        ];

        let deduped = protection::dedupe_fonts(fonts);

        let names_and_paths: Vec<(String, String)> = deduped
            .into_iter()
            .map(|f| (f.postscript_name, f.source.path.display().to_string()))
            .collect();

        assert_eq!(
            names_and_paths,
            vec![
                ("Alpha".into(), "/fonts/alpha-bold.ttf".into()),
                ("Alpha".into(), "/fonts/alpha.ttf".into()),
                ("Beta".into(), "/fonts/Beta.ttf".into()),
            ],
            "duplicates removed and order is deterministic by name then path"
        );
    }

    #[test]
    fn test_font_validation() {
        // Test valid font extensions
        assert!(validation::is_valid_font_extension(&PathBuf::from(
            "test.ttf"
        )));
        assert!(validation::is_valid_font_extension(&PathBuf::from(
            "test.otf"
        )));
        assert!(validation::is_valid_font_extension(&PathBuf::from(
            "test.OTF"
        )));
        assert!(validation::is_valid_font_extension(&PathBuf::from(
            "test.woff2"
        )));

        // Test invalid extensions
        assert!(!validation::is_valid_font_extension(&PathBuf::from(
            "test.txt"
        )));
        assert!(!validation::is_valid_font_extension(&PathBuf::from("test")));
        assert!(!validation::is_valid_font_extension(&PathBuf::from(
            "test.pdf"
        )));
    }

    #[test]
    fn test_basic_info_extraction() {
        let path = PathBuf::from("/fonts/Arial-Bold.ttf");
        let info = validation::extract_basic_info_from_path(&path);

        assert_eq!(info.source.path, path);
        assert_eq!(info.postscript_name, "Arial-Bold");
        assert_eq!(info.full_name, "Arial-Bold");
        assert_eq!(info.family_name, "Arial");
        assert_eq!(info.style, "Bold");
        assert_eq!(info.source.format, Some("TTF".to_string()));
    }

    #[test]
    fn detects_conflicts_by_path_postscript_and_family_style() {
        let installed = vec![
            FontliftFontFaceInfo::new(
                FontliftFontSource::new(PathBuf::from("/fonts/alpha-regular.ttf")),
                "AlphaPS".into(),
                "Alpha Regular".into(),
                "Alpha".into(),
                "Regular".into(),
            ),
            FontliftFontFaceInfo::new(
                FontliftFontSource::new(PathBuf::from("/fonts/alpha-bold.ttf")),
                "AlphaBoldPS".into(),
                "Alpha Bold".into(),
                "Alpha".into(),
                "Bold".into(),
            ),
            // different path but same family/style should count as conflict
            FontliftFontFaceInfo::new(
                FontliftFontSource::new(PathBuf::from("/other/alpha-regular.ttf")),
                "DifferentPS".into(),
                "Alpha Regular".into(),
                "Alpha".into(),
                "Regular".into(),
            ),
        ];

        let candidate = FontliftFontFaceInfo::new(
            FontliftFontSource::new(PathBuf::from("/Fonts/ALPHA-Regular.ttf")),
            "AlphaPS".into(),
            "Alpha Regular".into(),
            "Alpha".into(),
            "Regular".into(),
        );

        let conflicts = conflicts::detect_conflicts(&installed, &candidate);

        let paths: Vec<String> = conflicts
            .into_iter()
            .map(|f| f.source.path.to_string_lossy().to_lowercase())
            .collect();

        assert_eq!(paths.len(), 2);
        assert!(paths.contains(&"/fonts/alpha-regular.ttf".to_string()));
        assert!(paths.contains(&"/other/alpha-regular.ttf".to_string()));
        assert!(paths.iter().all(|p| p.contains("alpha")));
    }

    #[test]
    fn test_scope_description() {
        assert_eq!(FontScope::User.description(), "user-level");
        assert_eq!(FontScope::System.description(), "system-level");
    }

    #[test]
    fn test_cache_clear_result() {
        let result = cache::CacheClearResult::success(5, true)
            .with_warning("Some fonts may require restart".to_string());

        assert_eq!(result.entries_cleared, 5);
        assert!(result.restart_required);
        assert_eq!(result.warnings.len(), 1);
    }
}
```

# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/crates/fontlift-core/src/tests.rs
# Language: rust

mod integration_tests;


# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/crates/fontlift-core/src/validation_ext.rs
# Language: rust

mod tests;

struct ValidatorConfig {
}

struct ValidatorInput {
}

struct ValidationResult {
}


## crates/fontlift-platform-mac/Cargo.toml
```toml
[package]
name = "fontlift-platform-mac"
version.workspace = true
authors.workspace = true
edition.workspace = true
rust-version.workspace = true
license.workspace = true
repository.workspace = true
description = "macOS platform implementation for fontlift"

[dependencies]
fontlift-core = { workspace = true }
thiserror.workspace = true
anyhow.workspace = true
log.workspace = true

# macOS specific dependencies (objc2 ecosystem)
objc2-core-foundation = { workspace = true }
objc2-core-text = { workspace = true }
libc = "0.2"

[dev-dependencies]
tempfile = "3.0"
```

## crates/fontlift-platform-mac/src/lib.rs
```rust
//! macOS platform implementation for fontlift
//!
//! This module provides macOS-specific font management using Core Text APIs,
//! implementing the same functionality as the Swift CLI but in Rust.

use fontlift_core::{
    journal::{self, JournalAction},
    protection, validation,
    validation_ext::{self, ValidatorConfig},
    FontError, FontManager, FontResult, FontScope, FontliftFontFaceInfo, FontliftFontSource,
};
use std::env;
use std::fs;
use std::path::{Path, PathBuf};

use objc2_core_foundation::{
    CFDictionary, CFError, CFIndex, CFNumber, CFRetained, CFString, CFType, CFURLPathStyle, CFURL,
};
use objc2_core_text::{
    CTFontDescriptor, CTFontFormat, CTFontManagerScope,
    CTFontManagerRegisterFontsForURL, CTFontManagerUnregisterFontsForURL,
    kCTFontDisplayNameAttribute, kCTFontFamilyNameAttribute, kCTFontFormatAttribute,
    kCTFontNameAttribute, kCTFontStyleNameAttribute, kCTFontSymbolicTrait, kCTFontTraitsAttribute,
    kCTFontURLAttribute, kCTFontWeightTrait,
};

const K_CT_FONT_MANAGER_ERROR_ALREADY_REGISTERED: isize = 105;
const K_CT_FONT_MANAGER_ERROR_DUPLICATED_NAME: isize = 305;

fn test_cache_root() -> Option<PathBuf> {
    env::var_os("FONTLIFT_TEST_CACHE_ROOT").map(PathBuf::from)
}

fn user_home(test_root: &Option<PathBuf>) -> FontResult<PathBuf> {
    if let Some(root) = test_root.clone() {
        return Ok(root);
    }

    env::var("HOME").map(PathBuf::from).map_err(|_| {
        FontError::UnsupportedOperation(
            "Unable to resolve HOME directory for cache cleanup".to_string(),
        )
    })
}

fn fake_registry_root() -> Option<PathBuf> {
    env::var_os("FONTLIFT_FAKE_REGISTRY_ROOT").map(PathBuf::from)
}

#[allow(dead_code)]
fn fake_registry_target(root: &Path, scope: FontScope, source: &Path) -> FontResult<PathBuf> {
    let file_name = source.file_name().ok_or_else(|| {
        FontError::InvalidFormat("Font path must include a file name".to_string())
    })?;

    let base = match scope {
        FontScope::User => root.join("Library/Fonts"),
        FontScope::System => root.join("System/Library/Fonts"),
    };

    Ok(base.join(file_name))
}

fn delete_matching_files(root: &Path, predicate: impl Fn(&Path) -> bool) -> FontResult<usize> {
    if !root.exists() {
        return Ok(0);
    }

    let mut removed = 0usize;
    let mut stack = vec![root.to_path_buf()];

    while let Some(dir) = stack.pop() {
        let entries = match fs::read_dir(&dir) {
            Ok(entries) => entries,
            Err(err) if err.kind() == std::io::ErrorKind::NotFound => continue,
            Err(err) => return Err(FontError::IoError(err)),
        };

        for entry in entries {
            let entry = entry.map_err(FontError::IoError)?;
            let path = entry.path();

            if path.is_dir() {
                stack.push(path);
                continue;
            }

            if predicate(&path) {
                match fs::remove_file(&path) {
                    Ok(_) => removed += 1,
                    Err(err) if err.kind() == std::io::ErrorKind::NotFound => {}
                    Err(err) => return Err(FontError::IoError(err)),
                }
            }
        }
    }

    Ok(removed)
}

fn purge_directory_contents(root: &Path) -> FontResult<usize> {
    if !root.exists() {
        return Ok(0);
    }

    let mut removed = 0usize;
    let entries = fs::read_dir(root).map_err(FontError::IoError)?;

    for entry in entries {
        let entry = entry.map_err(FontError::IoError)?;
        let path = entry.path();

        if path.is_dir() {
            removed += purge_directory_contents(&path)?;
            match fs::remove_dir(&path) {
                Ok(_) => {}
                Err(err) if err.kind() == std::io::ErrorKind::NotFound => {}
                Err(err) => return Err(FontError::IoError(err)),
            }
        } else {
            fs::remove_file(&path).map_err(FontError::IoError)?;
            removed += 1;
        }
    }

    Ok(removed)
}

fn clear_adobe_font_caches(home: &Path) -> FontResult<usize> {
    // Adobe Font cache manifests (AdobeFnt*.lst) live under TypeSupport; remove them recursively
    let type_support = home.join("Library/Application Support/Adobe/TypeSupport");
    let removed_lists = delete_matching_files(&type_support, |path| {
        path.file_name()
            .and_then(|n| n.to_str())
            .map(|name| name.starts_with("AdobeFnt") && name.ends_with(".lst"))
            .unwrap_or(false)
    })?;

    // Adobe font cache files under Caches/Adobe/Fonts
    let fonts_cache = home.join("Library/Caches/Adobe/Fonts");
    let removed_cache = purge_directory_contents(&fonts_cache)?;

    Ok(removed_lists + removed_cache)
}

fn clear_office_font_cache(home: &Path) -> FontResult<usize> {
    // Microsoft Office font cache storage used by Office apps
    let office_cache = home.join("Library/Group Containers/UBF8T346G9.Office/FontCache");
    purge_directory_contents(&office_cache)
}

fn ct_scope(scope: FontScope) -> CTFontManagerScope {
    match scope {
        FontScope::User => CTFontManagerScope::User,
        FontScope::System => CTFontManagerScope::Persistent,
    }
}

fn cf_error_to_string(err: Option<&CFError>) -> String {
    match err {
        None => "unknown CoreText error".to_string(),
        Some(cf_err) => {
            // Get the error description
            match cf_err.description() {
                Some(desc) => cf_string_to_rust(&desc),
                None => "unknown CoreText error".to_string(),
            }
        }
    }
}

fn cf_string_to_rust(cf_str: &CFString) -> String {
    use objc2_core_foundation::CFStringBuiltInEncodings;

    // Get the length of the string
    let len = cf_str.length();
    if len == 0 {
        return String::new();
    }

    // Try to get a direct pointer to the UTF-8 representation
    let ptr = cf_str.c_string_ptr(CFStringBuiltInEncodings::EncodingUTF8.0);
    if !ptr.is_null() {
        // Safety: ptr is valid UTF-8 C string
        let c_str = unsafe { std::ffi::CStr::from_ptr(ptr) };
        return c_str.to_string_lossy().into_owned();
    }

    // Fallback: allocate a buffer and copy the string
    let max_size = (len as usize) * 4 + 1; // UTF-8 can be up to 4 bytes per character
    let mut buffer = vec![0u8; max_size];
    let success = unsafe {
        cf_str.c_string(
            buffer.as_mut_ptr() as *mut i8,
            max_size as CFIndex,
            CFStringBuiltInEncodings::EncodingUTF8.0,
        )
    };

    if success {
        // Find the null terminator
        let null_pos = buffer.iter().position(|&b| b == 0).unwrap_or(buffer.len());
        String::from_utf8_lossy(&buffer[..null_pos]).into_owned()
    } else {
        String::new()
    }
}

fn rust_string_to_cf(s: &str) -> CFRetained<CFString> {
    use objc2_core_foundation::CFStringBuiltInEncodings;

    let c_str = std::ffi::CString::new(s).unwrap_or_default();
    unsafe {
        CFString::with_c_string(None, c_str.as_ptr(), CFStringBuiltInEncodings::EncodingUTF8.0)
            .expect("Failed to create CFString")
    }
}

fn path_to_cfurl(path: &Path) -> Option<CFRetained<CFURL>> {
    let path_str = path.to_str()?;
    let cf_path = rust_string_to_cf(path_str);
    CFURL::with_file_system_path(
        None,
        Some(&cf_path),
        CFURLPathStyle::CFURLPOSIXPathStyle,
        path.is_dir(),
    )
}

fn cfurl_to_path(url: &CFURL) -> Option<PathBuf> {
    let cf_str = url.file_system_path(CFURLPathStyle::CFURLPOSIXPathStyle);
    cf_str.map(|s| PathBuf::from(cf_string_to_rust(&s)))
}

fn scope_from_path(path: &Path) -> FontScope {
    if let Some(fake_root) = fake_registry_root() {
        let user_fonts = fake_root.join("Library/Fonts");
        let system_fonts = fake_root.join("System/Library/Fonts");

        if path.starts_with(&user_fonts) {
            return FontScope::User;
        }

        if path.starts_with(&system_fonts) {
            return FontScope::System;
        }
    }

    if let Ok(home) = std::env::var("HOME") {
        let user_fonts = PathBuf::from(home).join("Library/Fonts");
        if path.starts_with(&user_fonts) {
            return FontScope::User;
        }
    }

    if path.starts_with("/System/Library/Fonts") || path.starts_with("/Library/Fonts") {
        FontScope::System
    } else {
        // Default to user to avoid over-reporting system scope for custom paths
        FontScope::User
    }
}

fn normalize_path(path: &Path) -> String {
    let mut normalized = path.to_string_lossy().replace('\\', "/").to_lowercase();

    while normalized.contains("//") {
        normalized = normalized.replace("//", "/");
    }

    normalized
}

fn font_format_to_string(format: CTFontFormat) -> Option<String> {
    if format == CTFontFormat::OpenTypePostScript {
        Some("OpenTypePostScript".to_string())
    } else if format == CTFontFormat::OpenTypeTrueType {
        Some("OpenTypeTrueType".to_string())
    } else if format == CTFontFormat::TrueType {
        Some("TrueType".to_string())
    } else if format == CTFontFormat::PostScript {
        Some("PostScript".to_string())
    } else if format == CTFontFormat::Bitmap {
        Some("Bitmap".to_string())
    } else {
        None
    }
}

fn is_conflict_error(err: &CFError) -> bool {
    let domain = match err.domain() {
        Some(d) => d,
        None => return false,
    };
    let domain_str = cf_string_to_rust(&domain);
    if !domain_str.contains("CTFontManagerErrorDomain") {
        return false;
    }

    let code = err.code();
    matches!(
        code,
        K_CT_FONT_MANAGER_ERROR_ALREADY_REGISTERED | K_CT_FONT_MANAGER_ERROR_DUPLICATED_NAME
    )
}

// Helper to check CF type - use ConcreteType trait
use objc2_core_foundation::ConcreteType;

fn get_descriptor_string_attribute(
    descriptor: &CTFontDescriptor,
    attr: &CFString,
) -> Option<String> {
    let value = unsafe { descriptor.attribute(attr) };
    value.and_then(|v| {
        // Check if it's a CFString using ConcreteType trait
        let type_id = objc2_core_foundation::CFGetTypeID(Some(v.as_ref()));
        let string_type_id = CFString::type_id();
        if type_id == string_type_id {
            // Cast to CFString - the value is a CFType, we need to reinterpret
            let cf_str: &CFString = unsafe { &*(v.as_ref() as *const CFType as *const CFString) };
            Some(cf_string_to_rust(cf_str))
        } else {
            None
        }
    })
}

fn get_descriptor_url_attribute(descriptor: &CTFontDescriptor) -> Option<PathBuf> {
    let value = unsafe { descriptor.attribute(kCTFontURLAttribute) };
    value.and_then(|v| {
        let type_id = objc2_core_foundation::CFGetTypeID(Some(v.as_ref()));
        let url_type_id = CFURL::type_id();
        if type_id == url_type_id {
            let cf_url: &CFURL = unsafe { &*(v.as_ref() as *const CFType as *const CFURL) };
            cfurl_to_path(cf_url)
        } else {
            None
        }
    })
}

fn get_descriptor_format_attribute(descriptor: &CTFontDescriptor) -> Option<CTFontFormat> {
    let value = unsafe { descriptor.attribute(kCTFontFormatAttribute) };
    value.and_then(|v| {
        let type_id = objc2_core_foundation::CFGetTypeID(Some(v.as_ref()));
        let number_type_id = CFNumber::type_id();
        if type_id == number_type_id {
            let cf_num: &CFNumber = unsafe { &*(v.as_ref() as *const CFType as *const CFNumber) };
            let mut format_value: u32 = 0;
            let success = unsafe {
                cf_num.value(
                    objc2_core_foundation::CFNumberType::SInt32Type,
                    (&mut format_value) as *mut u32 as *mut std::ffi::c_void,
                )
            };
            if success {
                Some(CTFontFormat(format_value))
            } else {
                None
            }
        } else {
            None
        }
    })
}

fn descriptor_to_font_face_info(descriptor: &CTFontDescriptor) -> Option<FontliftFontFaceInfo> {
    let path = get_descriptor_url_attribute(descriptor)?;
    let postscript_name =
        get_descriptor_string_attribute(descriptor, unsafe { kCTFontNameAttribute })?;
    let display_name =
        get_descriptor_string_attribute(descriptor, unsafe { kCTFontDisplayNameAttribute })
            .unwrap_or_else(|| postscript_name.clone());
    let family_name =
        get_descriptor_string_attribute(descriptor, unsafe { kCTFontFamilyNameAttribute })
            .unwrap_or_else(|| postscript_name.clone());
    let style_name =
        get_descriptor_string_attribute(descriptor, unsafe { kCTFontStyleNameAttribute })
            .unwrap_or_else(|| "Regular".to_string());

    let mut source = FontliftFontSource::new(path.clone()).with_scope(Some(scope_from_path(&path)));

    if let Some(format) = get_descriptor_format_attribute(descriptor) {
        source = source.with_format(font_format_to_string(format));
    }

    let mut info = FontliftFontFaceInfo::new(
        source,
        postscript_name,
        display_name,
        family_name,
        style_name,
    );

    // Try to get traits
    let traits_value = unsafe { descriptor.attribute(kCTFontTraitsAttribute) };
    if let Some(traits_cf) = traits_value {
        let type_id = objc2_core_foundation::CFGetTypeID(Some(traits_cf.as_ref()));
        let dict_type_id = CFDictionary::type_id();
        if type_id == dict_type_id {
            let traits_dict: &CFDictionary =
                unsafe { &*(traits_cf.as_ref() as *const CFType as *const CFDictionary) };

            // Get symbolic traits (for italic)
            let symbolic_key = unsafe { kCTFontSymbolicTrait };
            let symbolic_value = unsafe {
                traits_dict.value(symbolic_key as *const _ as *const std::ffi::c_void)
            };
            if !symbolic_value.is_null() {
                let cf_num: &CFNumber = unsafe { &*(symbolic_value as *const CFNumber) };
                let mut symbolic: u32 = 0;
                let success = unsafe {
                    cf_num.value(
                        objc2_core_foundation::CFNumberType::SInt32Type,
                        (&mut symbolic) as *mut u32 as *mut std::ffi::c_void,
                    )
                };
                if success {
                    // kCTFontItalicTrait = 1 << 0
                    info.italic = Some((symbolic & 1) != 0);
                }
            }

            // Get weight trait
            let weight_key = unsafe { kCTFontWeightTrait };
            let weight_value = unsafe {
                traits_dict.value(weight_key as *const _ as *const std::ffi::c_void)
            };
            if !weight_value.is_null() {
                let cf_num: &CFNumber = unsafe { &*(weight_value as *const CFNumber) };
                let mut weight: f64 = 0.0;
                let success = unsafe {
                    cf_num.value(
                        objc2_core_foundation::CFNumberType::Float64Type,
                        (&mut weight) as *mut f64 as *mut std::ffi::c_void,
                    )
                };
                if success {
                    let weight_int = (weight * 400.0 + 500.0).round();
                    if weight_int.is_finite() {
                        let clamped = weight_int.clamp(1.0, 1000.0) as u16;
                        info.weight = Some(clamped);
                    }
                }
            }
        }
    }

    Some(info)
}

/// macOS font manager using Core Text APIs
pub struct MacFontManager {
    fake_root: Option<PathBuf>,
    /// Optional validation config for pre-install validation
    validation_config: Option<ValidatorConfig>,
}

impl MacFontManager {
    /// Create a new macOS font manager
    pub fn new() -> Self {
        let fake_root = std::env::var_os("FONTLIFT_FAKE_REGISTRY_ROOT").map(PathBuf::from);
        Self {
            fake_root,
            validation_config: None,
        }
    }

    /// Create a manager with validation enabled
    pub fn with_validation(config: ValidatorConfig) -> Self {
        let fake_root = std::env::var_os("FONTLIFT_FAKE_REGISTRY_ROOT").map(PathBuf::from);
        Self {
            fake_root,
            validation_config: Some(config),
        }
    }

    /// Enable validation on this manager
    pub fn set_validation_config(&mut self, config: Option<ValidatorConfig>) {
        self.validation_config = config;
    }

    /// Whether the manager should avoid CoreText and operate against a fake registry root
    pub fn is_fake_registry_enabled(&self) -> bool {
        self.fake_root.is_some()
    }

    fn target_directory(&self, scope: FontScope) -> FontResult<PathBuf> {
        if let Some(root) = &self.fake_root {
            let dir = match scope {
                FontScope::User => root.join("Library/Fonts"),
                FontScope::System => root.join("System/Library/Fonts"),
            };
            return Ok(dir);
        }

        let target_dir = match scope {
            FontScope::User => {
                let home_dir = std::env::var("HOME").map_err(|_| {
                    FontError::PermissionDenied("Cannot determine home directory".to_string())
                })?;
                PathBuf::from(home_dir).join("Library/Fonts")
            }
            FontScope::System => PathBuf::from("/Library/Fonts"),
        };

        Ok(target_dir)
    }

    fn installed_target_path(
        &self,
        source: &FontliftFontSource,
        scope: FontScope,
    ) -> FontResult<PathBuf> {
        let file_name = source.path.file_name().ok_or_else(|| {
            FontError::InvalidFormat("Font path must include a file name".to_string())
        })?;

        Ok(self.target_directory(scope)?.join(file_name))
    }

    /// Extract font information using basic filename parsing as fallback
    fn get_font_info_from_path(&self, path: &Path) -> FontResult<FontliftFontFaceInfo> {
        validation::validate_font_file(path)?;

        let mut info = validation::extract_basic_info_from_path(path);
        info.source.scope = Some(scope_from_path(path));
        Ok(info)
    }

    /// Check if path is in system font directory
    fn is_system_font_path(&self, path: &Path) -> bool {
        protection::is_protected_system_font_path(path)
    }

    /// Check if current user has admin privileges
    fn has_admin_privileges(&self) -> bool {
        unsafe { libc::geteuid() == 0 }
    }

    /// Copy font to target directory based on scope
    fn copy_font_to_target_directory(
        &self,
        source_path: &Path,
        scope: FontScope,
        replace_existing: bool,
    ) -> FontResult<PathBuf> {
        let target_dir = self.target_directory(scope)?;
        let file_name = source_path.file_name().ok_or_else(|| {
            FontError::InvalidFormat("Font path must include a file name".to_string())
        })?;

        if scope == FontScope::System
            && !self.is_fake_registry_enabled()
            && !self.has_admin_privileges()
        {
            return Err(FontError::PermissionDenied(
                "System-level font installation requires administrator privileges. Run with --admin or use sudo.".to_string(),
            ));
        }

        // Create target directory if it doesn't exist
        if !target_dir.exists() {
            fs::create_dir_all(&target_dir).map_err(FontError::IoError)?;
        }

        // Check if font already exists in target location
        let target_path = target_dir.join(file_name);
        if target_path.exists() {
            if replace_existing {
                fs::remove_file(&target_path).map_err(FontError::IoError)?;
            } else {
                return Err(FontError::AlreadyInstalled(target_path));
            }
        }

        // Copy font file
        fs::copy(source_path, &target_path).map_err(FontError::IoError)?;

        Ok(target_path)
    }

    fn install_font_core_text(&self, path: &Path, scope: FontScope) -> FontResult<()> {
        // Validate the font prior to registration
        validation::validate_font_file(path)?;

        // Convert path to CFURL for Core Text
        let cf_url = match path_to_cfurl(path) {
            Some(url) => url,
            None => {
                return Err(FontError::InvalidFormat(format!(
                    "Cannot create CFURL from path: {}",
                    path.display()
                )))
            }
        };

        let mut error: *mut CFError = std::ptr::null_mut();
        let result =
            unsafe { CTFontManagerRegisterFontsForURL(&cf_url, ct_scope(scope), &mut error) };

        if result {
            return Ok(());
        }

        if error.is_null() {
            return Err(FontError::RegistrationFailed(format!(
                "Core Text failed to register font {}",
                path.display()
            )));
        }

        let error_ref = unsafe { &*error };
        if is_conflict_error(error_ref) {
            let mut unregister_error: *mut CFError = std::ptr::null_mut();
            let unregistered = unsafe {
                CTFontManagerUnregisterFontsForURL(&cf_url, ct_scope(scope), &mut unregister_error)
            };

            if !unregistered {
                let unregister_err = if unregister_error.is_null() {
                    None
                } else {
                    Some(unsafe { &*unregister_error })
                };
                return Err(FontError::RegistrationFailed(format!(
                    "Existing font conflict could not be resolved for {}: {}",
                    path.display(),
                    cf_error_to_string(unregister_err)
                )));
            }

            let mut retry_error: *mut CFError = std::ptr::null_mut();
            let retry = unsafe {
                CTFontManagerRegisterFontsForURL(&cf_url, ct_scope(scope), &mut retry_error)
            };

            if retry {
                return Ok(());
            }

            let retry_err = if retry_error.is_null() {
                None
            } else {
                Some(unsafe { &*retry_error })
            };
            return Err(FontError::RegistrationFailed(format!(
                "Core Text failed to register font {} after resolving conflict: {}",
                path.display(),
                cf_error_to_string(retry_err)
            )));
        }

        Err(FontError::RegistrationFailed(format!(
            "Core Text failed to register font {}: {}",
            path.display(),
            cf_error_to_string(Some(error_ref))
        )))
    }

    fn install_font_fake(&self, source: &FontliftFontSource, scope: FontScope) -> FontResult<()> {
        let path = &source.path;
        self.copy_font_to_target_directory(path, scope, true)?;
        Ok(())
    }

    fn uninstall_font_fake(&self, source: &FontliftFontSource, scope: FontScope) -> FontResult<()> {
        let target_path = self.installed_target_path(source, scope)?;
        if target_path.exists() {
            std::fs::remove_file(&target_path).map_err(FontError::IoError)?;
            Ok(())
        } else {
            Err(FontError::FontNotFound(target_path))
        }
    }

    #[allow(dead_code)]
    fn list_installed_fonts_fake(&self) -> FontResult<Vec<FontliftFontFaceInfo>> {
        let mut fonts = Vec::new();

        for scope in [FontScope::User, FontScope::System] {
            let dir = self.target_directory(scope)?;
            if !dir.exists() {
                continue;
            }

            for entry in fs::read_dir(&dir).map_err(FontError::IoError)? {
                let entry = entry.map_err(FontError::IoError)?;
                let path = entry.path();

                if !validation::is_valid_font_extension(&path) {
                    continue;
                }

                match self.get_font_info_from_path(&path) {
                    Ok(font) => fonts.push(font.with_scope(Some(scope))),
                    Err(_) => continue,
                }
            }
        }

        Ok(protection::dedupe_fonts(fonts))
    }

    /// Validate system operation permissions
    fn validate_system_operation(&self, scope: FontScope) -> FontResult<()> {
        if scope == FontScope::System
            && !self.is_fake_registry_enabled()
            && !self.has_admin_privileges()
        {
            return Err(FontError::PermissionDenied(
                "System-level font operations require administrator privileges. Run with --admin or use sudo.".to_string()
            ));
        }
        Ok(())
    }
}

impl Default for MacFontManager {
    fn default() -> Self {
        Self::new()
    }
}

impl FontManager for MacFontManager {
    fn install_font(&self, source: &FontliftFontSource) -> FontResult<()> {
        let scope = source.scope.unwrap_or(FontScope::User);
        let path = &source.path;
        // Validate inputs
        validation::validate_font_file(path)?;
        self.validate_system_operation(scope)?;

        // Out-of-process validation if configured
        if let Some(ref config) = self.validation_config {
            validation_ext::validate_single(path, config)?;
        }

        if self.is_system_font_path(path) && !self.is_fake_registry_enabled() {
            return Err(FontError::SystemFontProtection(path.to_path_buf()));
        }

        let target_path = self.installed_target_path(source, scope)?;
        let replace_existing = self.is_fake_registry_enabled() || scope == FontScope::User;

        if self.is_fake_registry_enabled() {
            return self.install_font_fake(source, scope);
        }

        // Build journal actions
        let needs_copy = target_path != *path;
        let mut actions = Vec::new();
        if needs_copy {
            actions.push(JournalAction::CopyFile {
                from: path.clone(),
                to: target_path.clone(),
            });
        }
        actions.push(JournalAction::RegisterFont {
            path: target_path.clone(),
            scope,
        });

        // Record operation in journal
        let mut journal = journal::load_journal().unwrap_or_default();
        let entry_id =
            journal.record_operation(actions, Some(format!("Install {}", path.display())));
        journal::save_journal(&journal)?;

        // Step 0: Copy file (if needed)
        let (target_path, created_copy) = if needs_copy {
            let result = self.copy_font_to_target_directory(path, scope, replace_existing);
            match result {
                Ok(copied_path) => {
                    // Mark step 0 complete
                    let mut j = journal::load_journal().unwrap_or_default();
                    let _ = j.mark_step(entry_id, 1);
                    let _ = journal::save_journal(&j);
                    (copied_path, true)
                }
                Err(e) => {
                    // Cleanup journal entry on failure
                    let mut j = journal::load_journal().unwrap_or_default();
                    let _ = j.mark_completed(entry_id);
                    let _ = journal::save_journal(&j);
                    return Err(e);
                }
            }
        } else {
            (target_path, false)
        };

        // Step 1 (or 0 if no copy): Register font
        let result = self.install_font_core_text(&target_path, scope);

        // Update journal
        let mut j = journal::load_journal().unwrap_or_default();
        if result.is_ok() {
            let _ = j.mark_completed(entry_id);
        } else {
            // Rollback: delete copied file on registration failure
            if created_copy {
                let _ = fs::remove_file(&target_path);
            }
            // Mark as completed (failed, but nothing to recover)
            let _ = j.mark_completed(entry_id);
        }
        let _ = journal::save_journal(&j);

        result
    }

    fn uninstall_font(&self, source: &FontliftFontSource) -> FontResult<()> {
        let scope = source.scope.unwrap_or(FontScope::User);
        self.validate_system_operation(scope)?;

        let target_path = self.installed_target_path(source, scope)?;

        if self.is_fake_registry_enabled() {
            return self.uninstall_font_fake(source, scope);
        }

        if !target_path.exists() {
            return Err(FontError::FontNotFound(target_path));
        }

        // Convert path to CFURL for Core Text
        let cf_url = match path_to_cfurl(&target_path) {
            Some(url) => url,
            None => {
                return Err(FontError::InvalidFormat(format!(
                    "Cannot create CFURL from path: {}",
                    target_path.display()
                )))
            }
        };

        let mut error: *mut CFError = std::ptr::null_mut();
        let result =
            unsafe { CTFontManagerUnregisterFontsForURL(&cf_url, ct_scope(scope), &mut error) };

        if result {
            Ok(())
        } else {
            let err = if error.is_null() {
                None
            } else {
                Some(unsafe { &*error })
            };
            let message = cf_error_to_string(err);
            Err(FontError::RegistrationFailed(format!(
                "Core Text failed to unregister font {}: {}",
                target_path.display(),
                message
            )))
        }
    }

    fn remove_font(&self, source: &FontliftFontSource) -> FontResult<()> {
        let scope = source.scope.unwrap_or(FontScope::User);
        let target_path = self.installed_target_path(source, scope)?;
        let installed_source = FontliftFontSource::new(target_path.clone()).with_scope(Some(scope));

        if self.is_system_font_path(&target_path) && !self.is_fake_registry_enabled() {
            return Err(FontError::SystemFontProtection(target_path));
        }

        // Skip journaling for fake registry
        if self.is_fake_registry_enabled() {
            self.uninstall_font(&installed_source)?;
            if target_path.exists() {
                std::fs::remove_file(&target_path).map_err(FontError::IoError)?;
            }
            return Ok(());
        }

        // Build journal actions: UnregisterFont â†’ DeleteFile
        let actions = vec![
            JournalAction::UnregisterFont {
                path: target_path.clone(),
                scope,
            },
            JournalAction::DeleteFile {
                path: target_path.clone(),
            },
        ];

        // Record operation in journal
        let mut journal = journal::load_journal().unwrap_or_default();
        let entry_id =
            journal.record_operation(actions, Some(format!("Remove {}", target_path.display())));
        journal::save_journal(&journal)?;

        // Step 0: Unregister font
        let unregister_result = self.uninstall_font(&installed_source);
        if let Err(e) = unregister_result {
            // Mark completed (nothing to recover from unregister failure)
            let mut j = journal::load_journal().unwrap_or_default();
            let _ = j.mark_completed(entry_id);
            let _ = journal::save_journal(&j);
            return Err(e);
        }

        // Mark step 0 complete
        {
            let mut j = journal::load_journal().unwrap_or_default();
            let _ = j.mark_step(entry_id, 1);
            let _ = journal::save_journal(&j);
        }

        // Step 1: Delete file
        if target_path.exists() {
            std::fs::remove_file(&target_path).map_err(FontError::IoError)?;
        }

        // Mark operation completed
        let mut j = journal::load_journal().unwrap_or_default();
        let _ = j.mark_completed(entry_id);
        let _ = journal::save_journal(&j);

        Ok(())
    }

    fn is_font_installed(&self, source: &FontliftFontSource) -> FontResult<bool> {
        let scope = source.scope.unwrap_or(FontScope::User);
        let target_path = self.installed_target_path(source, scope)?;

        if self.is_fake_registry_enabled() {
            return Ok(target_path.exists());
        }

        if target_path.exists() {
            return Ok(true);
        }

        let font_array = unsafe { objc2_core_text::CTFontManagerCopyAvailableFontURLs() };

        let normalized_target = normalize_path(&target_path);
        let count = font_array.count();

        for i in 0..count {
            let value = unsafe { font_array.value_at_index(i) };
            if value.is_null() {
                continue;
            }

            // Check if it's a CFURL
            let cf_type: &CFType = unsafe { &*(value as *const CFType) };
            let type_id = objc2_core_foundation::CFGetTypeID(Some(cf_type));
            let url_type_id = CFURL::type_id();
            if type_id != url_type_id {
                continue;
            }

            let cf_url: &CFURL = unsafe { &*(value as *const CFURL) };
            if let Some(path) = cfurl_to_path(cf_url) {
                if normalize_path(&path) == normalized_target {
                    return Ok(true);
                }
            }
        }

        Ok(false)
    }

    fn list_installed_fonts(&self) -> FontResult<Vec<FontliftFontFaceInfo>> {
        if self.is_fake_registry_enabled() {
            return self.list_installed_fonts_fake();
        }

        // Get all available font URLs from Core Text
        let font_array = unsafe { objc2_core_text::CTFontManagerCopyAvailableFontURLs() };

        let mut fonts = Vec::new();
        let count = font_array.count();

        for i in 0..count {
            let value = unsafe { font_array.value_at_index(i) };
            if value.is_null() {
                continue;
            }

            // Check if it's a CFURL
            let cf_type: &CFType = unsafe { &*(value as *const CFType) };
            let type_id = objc2_core_foundation::CFGetTypeID(Some(cf_type));
            let url_type_id = CFURL::type_id();
            if type_id != url_type_id {
                continue;
            }

            let cf_url: &CFURL = unsafe { &*(value as *const CFURL) };

            // Try to pull rich metadata via font descriptors first
            let descriptors =
                unsafe { objc2_core_text::CTFontManagerCreateFontDescriptorsFromURL(cf_url) };

            if let Some(descriptor_array) = descriptors {
                let desc_count = descriptor_array.count();

                for idx in 0..desc_count {
                    let desc_value = unsafe { descriptor_array.value_at_index(idx) };
                    if desc_value.is_null() {
                        continue;
                    }

                    let descriptor: &CTFontDescriptor =
                        unsafe { &*(desc_value as *const CTFontDescriptor) };
                    if let Some(info) = descriptor_to_font_face_info(descriptor) {
                        fonts.push(info);
                        continue;
                    }
                }
            }

            // Fallback: basic info from path
            if let Some(path) = cfurl_to_path(cf_url) {
                if !path.exists() || !validation::is_valid_font_extension(&path) {
                    continue;
                }

                match self.get_font_info_from_path(&path) {
                    Ok(mut font_info) => {
                        font_info.source.scope = Some(scope_from_path(&path));
                        fonts.push(font_info);
                    }
                    Err(_) => {
                        // Skip fonts we can't read, but don't fail the entire operation
                        continue;
                    }
                }
            }
        }

        Ok(protection::dedupe_fonts(fonts))
    }

    fn prune_missing_fonts(&self, scope: FontScope) -> FontResult<usize> {
        if self.is_fake_registry_enabled() {
            return Ok(0);
        }

        let font_array = unsafe { objc2_core_text::CTFontManagerCopyAvailableFontURLs() };

        let mut pruned = 0usize;
        let mut failures = Vec::new();
        let count = font_array.count();

        for i in 0..count {
            let value = unsafe { font_array.value_at_index(i) };
            if value.is_null() {
                continue;
            }

            let cf_type: &CFType = unsafe { &*(value as *const CFType) };
            let type_id = objc2_core_foundation::CFGetTypeID(Some(cf_type));
            let url_type_id = CFURL::type_id();
            if type_id != url_type_id {
                continue;
            }

            let cf_url: &CFURL = unsafe { &*(value as *const CFURL) };
            let path = cfurl_to_path(cf_url);

            if let Some(ref existing_path) = path {
                if scope_from_path(existing_path) != scope {
                    continue;
                }

                // Skip registrations that still have a backing file
                if existing_path.exists() {
                    continue;
                }
            } else if scope == FontScope::System && !self.has_admin_privileges() {
                // Don't attempt system pruning without privileges
                continue;
            }

            let mut error: *mut CFError = std::ptr::null_mut();
            let ok =
                unsafe { CTFontManagerUnregisterFontsForURL(cf_url, ct_scope(scope), &mut error) };

            if ok {
                pruned += 1;
            } else {
                let err = if error.is_null() {
                    None
                } else {
                    Some(unsafe { &*error })
                };
                failures.push(cf_error_to_string(err));
            }
        }

        if failures.is_empty() {
            Ok(pruned)
        } else {
            Err(FontError::RegistrationFailed(format!(
                "Failed to prune some font registrations: {}",
                failures.join("; ")
            )))
        }
    }

    fn clear_font_caches(&self, scope: FontScope) -> FontResult<()> {
        if self.is_fake_registry_enabled() {
            return Ok(());
        }

        let test_root = test_cache_root();
        let home = user_home(&test_root)?;
        let should_touch_system = test_root.is_none();

        match scope {
            FontScope::User => {
                if should_touch_system {
                    // Clear user font cache using atsutil
                    let output = std::process::Command::new("atsutil")
                        .args(["databases", "-removeUser"])
                        .output()
                        .map_err(FontError::IoError)?;

                    if !output.status.success() {
                        let stderr = String::from_utf8_lossy(&output.stderr);
                        return Err(FontError::RegistrationFailed(format!(
                            "Failed to clear user font cache: {}",
                            stderr
                        )));
                    }

                    // Restart ATS server for user session
                    let _ = std::process::Command::new("atsutil")
                        .args(["server", "-shutdown"])
                        .output();

                    let _ = std::process::Command::new("atsutil")
                        .args(["server", "-ping"])
                        .output();
                }

                // Vendor caches (Adobe/Microsoft) are per-user; remove safely under the resolved home dir
                clear_adobe_font_caches(&home)?;
                clear_office_font_cache(&home)?;
            }
            FontScope::System => {
                if should_touch_system {
                    // System cache clearing requires admin privileges
                    if !self.has_admin_privileges() {
                        return Err(FontError::PermissionDenied(
                            "System cache clearing requires administrator privileges".to_string(),
                        ));
                    }

                    // Clear system font cache using atsutil
                    let output = std::process::Command::new("atsutil")
                        .args(["databases", "-remove"])
                        .output()
                        .map_err(FontError::IoError)?;

                    if !output.status.success() {
                        let stderr = String::from_utf8_lossy(&output.stderr);
                        return Err(FontError::RegistrationFailed(format!(
                            "Failed to clear system font cache: {}",
                            stderr
                        )));
                    }

                    // Restart ATS server for system
                    let _ = std::process::Command::new("atsutil")
                        .args(["server", "-shutdown"])
                        .output();

                    let _ = std::process::Command::new("atsutil")
                        .args(["server", "-ping"])
                        .output();
                }
            }
        }

        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::fs;
    use std::path::PathBuf;
    use std::sync::{Mutex, OnceLock};

    fn fake_env_lock() -> &'static Mutex<()> {
        static LOCK: OnceLock<Mutex<()>> = OnceLock::new();
        LOCK.get_or_init(|| Mutex::new(()))
    }

    #[test]
    fn test_mac_font_manager_creation() {
        std::env::remove_var("FONTLIFT_FAKE_REGISTRY_ROOT");
        let manager = MacFontManager::new();
        assert!(!manager.is_fake_registry_enabled());
    }

    #[test]
    fn test_system_font_detection() {
        let manager = MacFontManager::new();

        // Test system font paths
        let system_path = PathBuf::from("/System/Library/Fonts/Arial.ttf");
        assert!(manager.is_system_font_path(&system_path));

        let library_path = PathBuf::from("/Library/Fonts/Helvetica.ttc");
        assert!(manager.is_system_font_path(&library_path));

        // Test user font paths
        let user_path = PathBuf::from("/Users/test/Library/Fonts/Custom.otf");
        assert!(!manager.is_system_font_path(&user_path));

        let temp_path = PathBuf::from("/tmp/test.ttf");
        assert!(!manager.is_system_font_path(&temp_path));
    }

    #[test]
    fn test_admin_detection() {
        let manager = MacFontManager::new();
        // This test will typically fail unless run as root
        let is_admin = manager.has_admin_privileges();
        // We can't assert a specific value as it depends on execution context
        println!("Running as admin: {}", is_admin);
    }

    #[test]
    fn test_font_validation() {
        let _manager = MacFontManager::new();

        // Test valid font file paths (these may not exist, just testing validation logic)
        let valid_path = PathBuf::from("/tmp/test.ttf");
        if validation::is_valid_font_extension(&valid_path) {
            // Test would pass if file existed
        }

        let invalid_path = PathBuf::from("/tmp/test.txt");
        assert!(!validation::is_valid_font_extension(&invalid_path));
    }

    #[test]
    fn scope_detection_maps_user_and_system_paths() {
        let user_path = PathBuf::from("/Users/demo/Library/Fonts/Custom.otf");
        let system_path = PathBuf::from("/Library/Fonts/SystemFont.ttf");
        let other_path = PathBuf::from("/tmp/random-font.ttf");

        assert_eq!(scope_from_path(&user_path), FontScope::User);
        assert_eq!(scope_from_path(&system_path), FontScope::System);
        assert_eq!(scope_from_path(&other_path), FontScope::User);
    }

    #[test]
    fn fake_registry_install_list_uninstall_round_trip() {
        let _env_lock = fake_env_lock().lock().expect("env lock");
        let temp = tempfile::tempdir().expect("tempdir");
        let fake_root = temp.path().join("fake-root");
        std::env::set_var("FONTLIFT_FAKE_REGISTRY_ROOT", &fake_root);

        let manager = MacFontManager::new();
        let source_font = temp.path().join("DemoFake.ttf");
        fs::write(&source_font, b"dummy font").expect("write font");

        let source = FontliftFontSource::new(source_font.clone()).with_scope(Some(FontScope::User));

        manager
            .install_font(&source)
            .expect("install in fake registry");

        let installed_path = fake_root.join("Library/Fonts/DemoFake.ttf");
        assert!(
            installed_path.exists(),
            "font should be copied into fake registry"
        );

        let listed = manager.list_installed_fonts().expect("list");
        assert_eq!(listed.len(), 1);
        assert_eq!(listed[0].source.scope, Some(FontScope::User));

        let installed_source =
            FontliftFontSource::new(installed_path.clone()).with_scope(Some(FontScope::User));

        manager
            .uninstall_font(&installed_source)
            .expect("uninstall from fake registry");
        assert!(
            !installed_path.exists(),
            "font file should be removed in fake registry"
        );

        std::env::remove_var("FONTLIFT_FAKE_REGISTRY_ROOT");
    }

    #[test]
    fn fake_registry_allows_system_scope_without_admin() {
        let _env_lock = fake_env_lock().lock().expect("env lock");
        let temp = tempfile::tempdir().expect("tempdir");
        let fake_root = temp.path().join("fake-root");
        std::env::set_var("FONTLIFT_FAKE_REGISTRY_ROOT", &fake_root);

        let manager = MacFontManager::new();
        let source_font = temp.path().join("DemoSystem.ttf");
        fs::write(&source_font, b"dummy font").expect("write font");

        let source =
            FontliftFontSource::new(source_font.clone()).with_scope(Some(FontScope::System));

        manager
            .install_font(&source)
            .expect("system install should bypass admin in fake mode");

        let installed_path = fake_root.join("System/Library/Fonts/DemoSystem.ttf");
        assert!(installed_path.exists());

        std::env::remove_var("FONTLIFT_FAKE_REGISTRY_ROOT");
    }

    #[test]
    fn is_font_installed_tracks_fake_registry_state() {
        struct EnvGuard;
        impl Drop for EnvGuard {
            fn drop(&mut self) {
                std::env::remove_var("FONTLIFT_FAKE_REGISTRY_ROOT");
            }
        }

        let _lock = fake_env_lock().lock().expect("env lock");
        let _guard = EnvGuard;
        let temp = tempfile::tempdir().expect("tempdir");
        let fake_root = temp.path().join("fake-root");
        std::env::set_var("FONTLIFT_FAKE_REGISTRY_ROOT", &fake_root);

        let manager = MacFontManager::new();
        let source_font = temp.path().join("DemoFake.ttf");
        fs::write(&source_font, b"dummy font").expect("write font");

        let source = FontliftFontSource::new(source_font.clone()).with_scope(Some(FontScope::User));

        assert!(
            !manager
                .is_font_installed(&source)
                .expect("check before install"),
            "font should not be marked installed before copying"
        );

        manager
            .install_font(&source)
            .expect("install in fake registry");
        assert!(
            manager
                .is_font_installed(&source)
                .expect("check after install"),
            "font should be marked installed after copy"
        );

        let installed_source =
            FontliftFontSource::new(fake_root.join("Library/Fonts/DemoFake.ttf"))
                .with_scope(Some(FontScope::User));

        manager
            .uninstall_font(&installed_source)
            .expect("uninstall from fake registry");

        assert!(
            !manager
                .is_font_installed(&source)
                .expect("check after uninstall"),
            "font should be absent after uninstall"
        );
    }

    #[test]
    fn reinstall_overwrites_existing_file_in_fake_registry() {
        struct EnvGuard;
        impl Drop for EnvGuard {
            fn drop(&mut self) {
                std::env::remove_var("FONTLIFT_FAKE_REGISTRY_ROOT");
            }
        }

        let _lock = fake_env_lock().lock().expect("env lock");
        let _guard = EnvGuard;
        let temp = tempfile::tempdir().expect("tempdir");
        let fake_root = temp.path().join("fake-root");
        std::env::set_var("FONTLIFT_FAKE_REGISTRY_ROOT", &fake_root);

        let manager = MacFontManager::new();
        let source_font = temp.path().join("DemoFake.ttf");

        fs::write(&source_font, b"version-one").expect("write v1");
        let source = FontliftFontSource::new(source_font.clone()).with_scope(Some(FontScope::User));
        manager.install_font(&source).expect("initial install");

        fs::write(&source_font, b"version-two").expect("write v2");
        manager
            .install_font(&source)
            .expect("reinstall should replace");

        let installed_path = fake_root.join("Library/Fonts/DemoFake.ttf");
        let contents = fs::read(&installed_path).expect("read installed copy");
        assert_eq!(
            contents, b"version-two",
            "reinstall should replace the existing file in fake registry"
        );
    }

    #[test]
    fn clear_font_caches_removes_vendor_caches_under_override_root() {
        use std::env;

        struct EnvGuard;
        impl Drop for EnvGuard {
            fn drop(&mut self) {
                env::remove_var("FONTLIFT_FAKE_REGISTRY_ROOT");
                env::remove_var("FONTLIFT_TEST_CACHE_ROOT");
            }
        }

        let _lock = fake_env_lock().lock().expect("env lock");
        let _guard = EnvGuard;
        env::remove_var("FONTLIFT_FAKE_REGISTRY_ROOT");

        let tmp = tempfile::tempdir().expect("tempdir");
        let root = tmp.path();

        let adobe_type_support = root.join("Library/Application Support/Adobe/TypeSupport/More");
        fs::create_dir_all(&adobe_type_support).expect("adobe type support dir");
        let adobe_list = adobe_type_support.join("AdobeFnt11.lst");
        fs::write(&adobe_list, b"cache").expect("adobe list");

        let adobe_cache_dir = root.join("Library/Caches/Adobe/Fonts");
        fs::create_dir_all(&adobe_cache_dir).expect("adobe cache dir");
        let adobe_cache_file = adobe_cache_dir.join("fonts.bin");
        fs::write(&adobe_cache_file, b"cache").expect("adobe cache");

        let office_cache_dir = root.join("Library/Group Containers/UBF8T346G9.Office/FontCache");
        fs::create_dir_all(&office_cache_dir).expect("office cache dir");
        let office_cache_file = office_cache_dir.join("fontcache.dat");
        fs::write(&office_cache_file, b"cache").expect("office cache");

        env::set_var("FONTLIFT_TEST_CACHE_ROOT", root);
        let manager = MacFontManager::new();
        manager
            .clear_font_caches(FontScope::User)
            .expect("clear caches");

        assert!(
            !adobe_list.exists(),
            "Adobe font list cache should be removed"
        );
        assert!(
            !adobe_cache_file.exists(),
            "Adobe font cache file should be removed"
        );
        assert!(
            fs::read_dir(&office_cache_dir)
                .expect("office dir")
                .next()
                .is_none(),
            "Office font cache directory should be emptied"
        );
    }
}
```

## crates/fontlift-platform-win/Cargo.toml
```toml
[package]
name = "fontlift-platform-win"
version.workspace = true
authors.workspace = true
edition.workspace = true
rust-version.workspace = true
license.workspace = true
repository.workspace = true
description = "Windows platform implementation for fontlift"

[dependencies]
fontlift-core = { workspace = true }
thiserror.workspace = true
anyhow.workspace = true
log.workspace = true
read-fonts = "0.36"

# Windows specific dependencies
[target.'cfg(windows)'.dependencies]
winreg = "0.52"
windows = { version = "0.54", features = [
  "Win32_Foundation",
  "Win32_Graphics_Gdi",
  "Win32_Storage_FileSystem",
  "Win32_System_Registry",
  "Win32_UI_Shell",
  "Win32_Security",
  "Win32_System_Threading",
  "Win32_UI_WindowsAndMessaging",
  "Win32_System_Memory",
] }

[dev-dependencies]
tempfile = "3.0"
```

# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/crates/fontlift-platform-win/src/lib.rs
# Language: rust

mod tests;

struct WinFontManager {
}

struct EnvGuard {
}


## crates/fontlift-python/Cargo.toml
```toml
[package]
name = "fontlift-python"
version.workspace = true
authors.workspace = true
edition.workspace = true
rust-version.workspace = true
license.workspace = true
repository.workspace = true
description = "Python bindings for fontlift"

[lib]
# Name the compiled library `_native` so the exported `PyInit__native` symbol
# matches the Python import path `fontlift._native` configured in pyproject.toml.
name = "_native"
# Include "rlib" to allow cargo test to link; "cdylib" for the Python extension.
crate-type = ["cdylib", "rlib"]

[dependencies]
fontlift-core = { workspace = true }
pyo3 = { workspace = true, optional = true }
thiserror.workspace = true
anyhow.workspace = true
log.workspace = true
tokio.workspace = true

# Platform-specific dependencies
[target.'cfg(target_os = "macos")'.dependencies]
fontlift-platform-mac = { workspace = true }

[target.'cfg(target_os = "windows")'.dependencies]
fontlift-platform-win = { workspace = true }

[features]
python-bindings = ["pyo3", "pyo3/extension-module"]
default = []

[build-dependencies]
pyo3-build-config = "0.24.1"
```

# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/crates/fontlift-python/build.rs
# Language: rust



# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/crates/fontlift-python/src/bindings.rs
# Language: rust

mod tests;

struct PyFontSource {
}

struct PyFontFaceInfo {
}

struct FontliftManager {
}

struct FakeManager {
}

struct RecordingManager {
}


# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/crates/fontlift-python/src/lib.rs
# Language: rust

mod bindings;

mod stub;

mod feature_flags;


# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/crates/fontlift-python/src/stub.rs
# Language: rust



## crates/fontlift-validator/Cargo.toml
```toml
[package]
name = "fontlift-validator"
version.workspace = true
authors.workspace = true
edition.workspace = true
rust-version.workspace = true
repository.workspace = true
license.workspace = true
description = "Out-of-process font validation helper for fontlift"

[[bin]]
name = "fontlift-validator"
path = "src/main.rs"

[dependencies]
fontlift-core.workspace = true
read-fonts = "0.26"
serde.workspace = true
serde_json.workspace = true
thiserror.workspace = true

[dev-dependencies]
tempfile.workspace = true
```

# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/crates/fontlift-validator/src/main.rs
# Language: rust

mod tests;

struct ValidatorConfig {
}

struct ValidatorInput {
}

struct ValidationResult {
}


# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/examples/basic_usage.rs
# Language: rust

mod tests;


## publish.sh
```bash
#!/usr/bin/env bash

set -euo pipefail

ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

tag="${1:-}"
if [[ -z "$tag" ]]; then
	if git describe --tags --exact-match >/dev/null 2>&1; then
		tag=$(git describe --tags --exact-match)
	else
		echo "Usage: ./publish.sh vX.Y.Z"
		exit 1
	fi
fi

version="${tag#v}"
echo "Publishing FontLift version ${version}"

cd "$ROOT"

echo "Building release artifacts..."
cargo build -p fontlift-cli --release

echo "Publishing crates.io packages..."
cargo publish -p fontlift-core
cargo publish -p fontlift-platform-mac || true
cargo publish -p fontlift-platform-win || true
cargo publish -p fontlift-cli
cargo publish -p fontlift-python

echo "Preparing Python wheel..."
uv venv --clear
source .venv/bin/activate
uv pip install --upgrade pip hatch hatchling hatchling-pyo3-plugin hatch-vcs fire
uvx hatch build -t wheel

echo "Publishing to PyPI..."
uv publish

echo "Done."
```

## pyproject.toml
```toml
[build-system]
requires = ["maturin>=1.7,<2.0"]
build-backend = "maturin"

[project]
name = "fontlift"
description = "FontLift Python bindings and CLI powered by PyO3"
readme = "README.md"
requires-python = ">=3.10"
license = { file = "LICENSE" }
authors = [{ name = "FontLab Ltd." }]
keywords = ["fonts", "font management", "pyo3", "rust"]
classifiers = [
  "License :: OSI Approved :: Apache Software License",
  "Programming Language :: Python :: 3",
  "Programming Language :: Python :: 3 :: Only",
  "Programming Language :: Rust",
  "Operating System :: MacOS :: MacOS X",
  "Operating System :: Microsoft :: Windows",
]
dependencies = ["fire>=0.5"]
dynamic = ["version"]

[project.scripts]
fontliftpy = "fontlift.cli:main"

[tool.maturin]
manifest-path = "crates/fontlift-python/Cargo.toml"
python-source = "python"
features = ["python-bindings"]
module-name = "fontlift._native"
strip = true
```

# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/python/fontlift/__init__.py
# Language: python

from importlib import import_module
from typing import Any, Dict, List, Mapping

def _require_native(()) -> None:

def _font_to_dict((font: Any)) -> Dict[str, Any]:

def list_fonts(()) -> List[Dict[str, Any]]:

def install((font_path: str, admin: bool = False, dry_run: bool = False)) -> None:

def uninstall((
    font_path: str | None = None,
    *,
    name: str | None = None,
    admin: bool = False,
    dry_run: bool = False,
)) -> None:

def remove((
    font_path: str | None = None,
    *,
    name: str | None = None,
    admin: bool = False,
    dry_run: bool = False,
)) -> None:

def cleanup((
    admin: bool = False,
    *,
    prune: bool = True,
    cache: bool = True,
    dry_run: bool = False,
)) -> None:


# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/python/fontlift/cli.py
# Language: python

import sys
import fire
from . import cleanup, install, list_fonts, remove, uninstall
from .render import ListRenderOptions, render_list_output

class FontliftCLI:
    def list((
        self,
        *,
        path: bool = False,
        name: bool = False,
        sorted: bool = False,  # noqa: A002
        json: bool = False,  # noqa: A002
    )) -> None:
    def install((
        self,
        path: str,
        *,
        admin: bool = False,
        dry_run: bool = False,
        quiet: bool = False,
        verbose: bool = False,
    )) -> None:
    def uninstall((
        self,
        path: str | None = None,
        *,
        name: str | None = None,
        admin: bool = False,
        dry_run: bool = False,
        quiet: bool = False,
        verbose: bool = False,
    )) -> None:
    def remove((
        self,
        path: str | None = None,
        *,
        name: str | None = None,
        admin: bool = False,
        dry_run: bool = False,
        quiet: bool = False,
        verbose: bool = False,
    )) -> None:
    def cleanup((
        self,
        admin: bool = False,
        prune: bool = True,
        cache: bool = True,
        dry_run: bool = False,
        quiet: bool = False,
        verbose: bool = False,
    )) -> None:

def _log_status((message: str, quiet: bool)) -> None:

def _log_verbose((message: str, quiet: bool, verbose: bool)) -> None:

def list((
        self,
        *,
        path: bool = False,
        name: bool = False,
        sorted: bool = False,  # noqa: A002
        json: bool = False,  # noqa: A002
    )) -> None:

def install((
        self,
        path: str,
        *,
        admin: bool = False,
        dry_run: bool = False,
        quiet: bool = False,
        verbose: bool = False,
    )) -> None:

def uninstall((
        self,
        path: str | None = None,
        *,
        name: str | None = None,
        admin: bool = False,
        dry_run: bool = False,
        quiet: bool = False,
        verbose: bool = False,
    )) -> None:

def remove((
        self,
        path: str | None = None,
        *,
        name: str | None = None,
        admin: bool = False,
        dry_run: bool = False,
        quiet: bool = False,
        verbose: bool = False,
    )) -> None:

def cleanup((
        self,
        admin: bool = False,
        prune: bool = True,
        cache: bool = True,
        dry_run: bool = False,
        quiet: bool = False,
        verbose: bool = False,
    )) -> None:

def main((argv: list[str] | None = None)) -> None:


# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/python/fontlift/render.py
# Language: python

import json
from dataclasses import dataclass
from pathlib import Path
from typing import Dict, List, Tuple

class ListRenderOptions:

class ListRender:
    def __init__((self, kind: str, payload)):

def __init__((self, kind: str, payload)):

def is_json((self)) -> bool:

def lines((self)) -> List[str]:

def json((self)) -> str:

def _normalize_path((font: Dict[str, str])) -> str:

def _dedupe_fonts((fonts: List[Dict[str, str]])) -> List[Dict[str, str]]:

def render_list_output((fonts: List[Dict[str, str]], opts: ListRenderOptions)) -> ListRender:


# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/python/tests/conftest.py
# Language: python

import pathlib
import sys
import pytest
import fontlift._native

REPO_PYTHON_PATH = =

def pytest_collection_modifyitems((config, items)):


# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/python/tests/test_import.py
# Language: python

import importlib
import pytest

def fontlift_modules(()):

def test_version_matches_native((fontlift_modules)) -> None:

def test_cleanup_dry_run_is_noop((fontlift_modules)) -> None:


# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/python/tests/test_render.py
# Language: python

import pathlib
import sys
from fontlift.render import ListRenderOptions, render_list_output

REPO_PYTHON_PATH = =

def sample_fonts(()):

def test_render_list_defaults_show_paths_sorted_and_dedupes(()):

def test_render_list_with_names_only_outputs_names_sorted(()):

def test_render_list_json_is_deterministic_and_deduped(()):


## tests/fixtures/README.md
```markdown
# Test font fixtures

- `fonts/AtkinsonHyperlegible-Regular.ttf` (SIL Open Font License 1.1) copied from https://github.com/googlefonts/atkinson-hyperlegible (commit current as of 2025-12-03) for test-only use.
- `fonts/AtkinsonHyperlegible-Regular.otf` (SIL Open Font License 1.1) copied from https://github.com/googlefonts/atkinson-hyperlegible (commit current as of 2025-12-03) for test-only use.
- `fonts/AtkinsonHyperlegible-Regular.ttc` (SIL Open Font License 1.1) collection generated locally from the upstream TTF using a minimal TTC header for test-only use.
```

## tests/fixtures/fonts/malformed.ttf
```
NOT A FONT FILE
```

## tests/fixtures/golden_outputs/list_json_schema.json
```json
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$id": "fontlift-list-output",
  "title": "FontLift List Output Schema",
  "description": "Expected JSON output structure for fontlift list --json",

... (Data file content truncated to first 5 lines)
```

# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/tests/integration_tests.rs
# Language: rust



# File: /Users/adam/Developer/vcs3/github.fontlaborg/fontlift/tests/test_fonts.rs
# Language: rust

mod tests;

struct TestFont {
}

struct TestFontDataset {
}